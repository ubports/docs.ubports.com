# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019-2024, The UBports project (Creative Commons BY-SA 4.0)
# This file is distributed under the same license as the UBports package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: UBports \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-12-16 10:14+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../porting/UpdatePortsFor2004.rst:4
msgid "Update ports for Ubuntu Touch 20.04"
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:6
msgid "Ubuntu Touch 20.04 introduces a lot of changes underneath, which requires changes from the porters. This document is intended to serve as an overview on how to make your port run on Ubuntu Touch 20.04. However, every port is different, and may require more than what is outlined in this document. We'll be available in `the UBports porting Telegram group <https://docs.ubports.com/en/latest/porting/introduction/Intro.html#getting-community-help>`_ to answer any question that might occur during process."
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:9
msgid "For GitLab CI-based ports: switch to shared building script & GitLab CI configuration"
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:11
msgid "Because of changes in how Ubuntu Touch 20.04's rootfs is made, we need to changes the way device tarballs are built. Instead of cherry-picking script changes from other port's repository, we recommend transitioning to the shared building script. By using the shared script, your port will receive the latest changes in device tarball building as rootfs continues to evolve (e.g. for 22.04 or newer). To transition to the shared script, remove the whole ``build/`` directory, and replace the content of ``build.sh`` with:"
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:21
msgid "You may want to add ``build/`` into your ``.gitignore``."
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:23
msgid "And for the same reason, we recommend using the shared GitLab CI configuration so that when the shared script has its requirement changes, your port will not be broken. Using the shared config can be done by replacing the content of ``.gitlab-ci.yml`` with:"
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:33
msgid "The ``variables`` section enables building the flashable partition image from the Focal rootfs, which you might want to leave out for intial porting."
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:36
msgid "The script currently doesn't handle the single repository which builds for multiple devices. If your port needs this feature, please upvote `this issue <https://gitlab.com/ubports/porting/community-ports/halium-generic-adaptation-build-tools/-/issues/5>`_."
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:38
msgid "If you have custom changes in the build script or in the GitLab CI configuration, you may need to carefully inspect the changes to make sure that your port will still work. Note that you can add additional steps to the GitLab CI configuration and order it after the device tarball building steps, or even overriding some steps (not recommended)."
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:41
msgid "For GitLab CI-based ports: inspect your overlay in Android partitions"
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:43
msgid "Many ports overlay the files in Android partitions to makes the port work. This is often achived by overlaying the ``mount-android.conf`` Upstart job to either contain the code itself, or to call another script. Since Ubuntu Touch 20.04 no longers use Upstart (see below), the code will no longer run. If your port ships your overlay files under ``/opt/halium-overlay`` or ``/usr/share/halium-overlay``, the new overlay system will take care of it automatically, except when the new file is added in which case you may need ``.halium-overlay-dir`` (see :ref:`Overlay`)."
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:45
msgid "Alternatively, you may want to consider moving your port completely to use the `overlaystore` system. However the migration is not straight forward and it will make your port incompatible with 16.04 (unless you have another branch). Contact @peat-psuwit in the UBports porting group for more info."
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:48
msgid "For Halium 7 ports or older: update bluetooth-touch script"
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:50
msgid "The way bluetooth-touch script used to work is inherently tied to Upstart. In Ubuntu Touch 20.04, bluetooth-touch is migrated to use Systemd. So, instead of overlaying ``bluetooth-touch-android.conf`` Upstart job, you'll have to overlay ``/usr/share/bluetooth-touch/android.sh``. Note that the script will be run by ``/bin/sh``, so avoid Bash-ism here."
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:52
msgid "Halium 9 ports doesn't require this, as Bluebinder replaces ``bluetooth-touch`` by directly talking to HIDL service to provide Bluetooth host interface."
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:55
msgid "For everyone: configure usb-moded"
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:57
msgid "usb-moded replaces ``setupusb`` script in setting and managing USB modes. We've written a specific page for that. See :ref:`USBModed`."
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:60
msgid "For everyone: check custom Upstart jobs"
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:62
msgid "Some ports has custom Upstart jobs to do certain things on boot. Those jobs has to be converted to Systemd units in order to run at all in Ubuntu Touch 20.04. One may find `Ubuntu's guide on this topic <https://wiki.ubuntu.com/SystemdForUpstartUsers#Job_vs._unit_keywords>` useful."
msgstr ""

#: ../../porting/UpdatePortsFor2004.rst:64
msgid "Alternatively, instead of writing custom Systemd units, use ``devicehack`` script which will run on every boot after the Android container runs. The path is ``/usr/libexec/lxc-android-config/device-hacks``, and the script will be run with ``/bin/sh``."
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:4
msgid "Booting"
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:6
msgid "In the previous sections you completed building and installing Ubuntu Touch on your device. The next step is to boot the device, gain remote access and debug as necessary."
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:9
msgid "What is a successful boot?"
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:11
msgid "When you boot your build for the first time you will normally not get anything on the screen. This is not necessarily an indication of something gone wrong. Your system may well have booted successfully and this can be ascertained by gaining remote access."
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:13
msgid "If your system booted successfully, you will be able to connect to your device from your host using ssh and continue debugging and configuring from there."
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:15
msgid "If something went wrong, you should normally be offered a telnet connection through which you can proceed with debugging. If you don't get either of these, the problem might be more difficult to determine. If you get stuck don't hesitate to seek help."
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:18
msgid "Gaining remote access"
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:20
msgid "When your device boots it will likely stay at the bootloader screen. However, you should also get a new network connection on the computer you have it plugged in to. To determine if this is the case, and what type of connection you have been offered, proceed as described below."
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:23
msgid "ssh connection"
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:25
msgid "To confirm that your device has booted correctly, on your host computer, run dmesg -w and watch for “GNU/Linux device” in the output. This confirms that you can establish an ssh connection to the device (see below). If you instead get something similar to “Halium initrd Failed to boot”, skip to :ref:`telnet`."
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:27
msgid "Establish an ssh connection to your device as follows:"
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:29
msgid "Your computer should now have a newly connected RNDIS interface. Check the output of ``ip link show`` for the device name. The device name will most likely resemble ``enp0s29u1u1``. Assign this device a fake MAC address (if the default one is all 00s) and an IP of 10.15.19.100::"
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:35
msgid "Once finished, you should be able to login with the following::"
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:39
msgid "The password will be the one you set when you ran the halium-install script."
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:44
msgid "telnet connection"
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:46
msgid "If you have been offered a telnet connection the rootfs and system image have likely not been found and mounted at boot time. This may indicate that one or more partitions have not been mounted as they should. Connect to your device with the following command::"
msgstr ""

#: ../../porting/build_and_boot/Boot_debug.rst:50
msgid "From here you can start debugging to find out what went wrong. Please :ref:`seek help <Getting-community-help>` to find out how to proceed."
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:2
msgid "Halium-7.1 - Building"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:4
msgid "For Halium-7.1 porting it is necessary to build both halium-boot.img and system.img."
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:7
#: ../../porting/build_and_boot/H9_build.rst:10
msgid "Initializing the build environment"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:9
msgid "First you need to initialize the environment using the envsetup.sh tool included in your source tree. Enter your BUILDDIR and issue the command::"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:13
msgid "The output will look like this::"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:21
msgid "The ``breakfast`` command is used to set up the build environment for a specific device. From the root of your BUILDDIR run the following, replacing [CODENAME] with your device's specific codename::"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:25
#: ../../porting/build_and_boot/H9_build.rst:28
msgid "Breakfast will attempt to find your device, set up all of the environment variables needed for building, and give you a summary at the end."
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:30
#: ../../porting/build_and_boot/H9_build.rst:33
msgid "Modify the kernel configuration"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:32
#: ../../porting/build_and_boot/H9_build.rst:35
msgid "The default LineageOS/Halium kernel configuration file needs modifications as Ubuntu Touch requires a slightly different kernel config than Halium, including enabling Apparmor. A script that does this job is provided in your Halium source tree: ``BUILDDIR/halium/halium-boot/check-kernel-config``."
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:34
#: ../../porting/build_and_boot/H9_build.rst:37
msgid "Locate your configuration file. It should be at ``arch/arm/configs/<CONFIG>`` or ``arch/arm64/configs/<CONFIG>`` depending on the architecture of your device. If you have trouble finding it, run ``grep \"TARGET_KERNEL_CONFIG\" device/<VENDOR>/<CODENAME>/BoardConfig.mk`` to determine the location."
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:36
msgid "Then, from the root of your BUILDDIR, run::"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:40
#: ../../porting/build_and_boot/H9_build.rst:43
msgid "You may have to do this twice. It will likely fix things both times. Then, run the script without the ``-w`` flag to see if there are any more errors. If there are, fix them manually. Once finished, run the script without the ``-w`` flag one more time to make sure everything is correct."
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:43
#: ../../porting/build_and_boot/H9_build.rst:46
msgid "Ubuntu Touch requires setting console=tty0"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:45
#: ../../porting/build_and_boot/H9_build.rst:48
msgid "The halium-boot initramfs expects ``/dev/console`` to be a console device and will not start init if it is not available. This is commonly the case on recent devices, because they either have UART disabled or ``console=`` is not specified (null) by default. This can be fixed by supplying ``console=tty0`` as the last argument in the kernel cmdline. To achieve this, proceed as follows:"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:47
#: ../../porting/build_and_boot/H9_build.rst:50
msgid "It should be done in the makefile named ``BoardConfig.mk`` (or ``BoardConfigCommon.mk``) located in the root directory of your device tree, e.g. ``~/halium/device/<vendor>/<model_codename>/BoardConfig.mk``"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:49
#: ../../porting/build_and_boot/H9_build.rst:52
msgid "Add the following line::"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:53
#: ../../porting/build_and_boot/H9_build.rst:56
msgid "If your makefile already includes a line beginning with ``BOARD_KERNEL_CMDLINE``, you may add it just below that to keep things tidy."
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:56
#: ../../porting/build_and_boot/H9_build.rst:59
msgid "The above method, although the preferred one, may not work for some Samsung devices. The result will be that you cannot get access to the device through ssh after boot, and Unity 8 will not be able to start. If you run into this problem, you can specify the setting in your device's kernel config file instead. Add the following lines::"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:62
#: ../../porting/build_and_boot/H9_build.rst:65
msgid "In rare cases the bootloader overwrites the kernel command line argument, rendering the setting above useless. This is the case for the Google Pixel 3a (sargo). To deal with this issue, replicate `this commit <https://github.com/fredldotme/android_kernel_google_bonito/commit/d0741dded3907f2cf4ecdc02bfcb74fc252763ff>`_."
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:65
#: ../../porting/build_and_boot/H9_build.rst:90
msgid "Build"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:67
msgid "Halium will use the mkbootimg tool for creating the boot image. In most cases it is not on the local harddisk, so it can be built by issuing::"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:71
#: ../../porting/build_and_boot/H9_build.rst:96
msgid "Now build the ``halium-boot.img`` using the commands::"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:78
#: ../../porting/build_and_boot/H9_build.rst:103
msgid "If you prefer ``make`` instead of ``mka`` you should set ``-j[num]`` for parallel building, which reduces build time. Replace ``[num]`` with the number of threads in your system plus 2."
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:81
#: ../../porting/build_and_boot/H9_build.rst:106
msgid "Build errors"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:83
#: ../../porting/build_and_boot/H9_build.rst:108
msgid "There are a number of known build errors which you might encounter, depending first of all upon how rigorous you have been in following the steps outlined, but you may also run into unforeseen issues. If your build fails at first, make sure you have done exactly as described, then go through the list of `known errors in the Halium guide <https://docs.halium.org/en/latest/porting/common-kernel-build-errors.html#common-kernel-build-errors>`_."
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:85
msgid "I your particular error is not listed, you will need to do some research of your own. If you end up here, know that there is a community of porters, developers and enthusiasts who might be able to help you. Refer to :ref:`Getting-community-help`."
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:90
#: ../../porting/build_and_boot/H9_build.rst:115
msgid "Building the system image (system.img)"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:92
msgid "Once you have successfully built halium-boot.img you can proceed to directly to building system.img::"
msgstr ""

#: ../../porting/build_and_boot/H7_build.rst:96
msgid "Likelier than not, you will run into one or more errors along the way when building the system image. A number of possible errors are documented in `the Halium guide <https://docs.halium.org/en/latest/porting/common-system-build-errors.html#common-system-build-errors>`_. If yours is not listed, :ref:`seek community help <Getting-community-help>`."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:2
msgid "Halium-7.1 - Setting up the sources"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:4
msgid "The sources necessary for the **full system image build** for Halium-7.1. Halium 7 requires a **full system image build**."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:7
msgid "Setting up the sources for Halium-7.1 builds"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:9
#: ../../porting/build_and_boot/H9_setup_sources.rst:7
msgid "Create a directory for your Halium source tree::"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:13
#: ../../porting/build_and_boot/H9_setup_sources.rst:11
msgid "This directory will be referred to as BUILDDIR throughout the remainder of this guide."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:15
msgid "First, initialize your source to the correct version of Halium::"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:19
msgid "Then download the code by issuing the command::"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:23
#: ../../porting/build_and_boot/H9_setup_sources.rst:23
msgid "The download will take some time as it counts several gigabytes. If you have a fast internet connection, you may set an extra JOBS=[number] environment variable at the beginning of the command to open more parallel downloading jobs. Generally, 12 is recommended, which is the default. When it completes, your BUILDDIR will contain a copy of the Halium source tree, but important parts are still missing."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:26
#: ../../porting/build_and_boot/H9_setup_sources.rst:26
msgid "Adding your device-specific source"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:28
#: ../../porting/build_and_boot/H9_setup_sources.rst:28
msgid "The next step is to add the device-specific sources that need to be integrated into the source tree before you can attempt to build. The missing sources are those required to build the kernel as well as a host of other hardware-specific components of the port."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:30
#: ../../porting/build_and_boot/H9_setup_sources.rst:30
msgid "The necessary sources need to be located and specified by creating a device manifest file (or editing an existing one) in the directory ``BUILDDIR/halium/devices/manifests``."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:33
#: ../../porting/build_and_boot/H9_setup_sources.rst:33
msgid "A correct device manifest is crucial to the success of your port."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:36
#: ../../porting/build_and_boot/H9_setup_sources.rst:36
msgid "Locating the sources"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:38
#: ../../porting/build_and_boot/H9_setup_sources.rst:38
msgid "Locate your device repository on `LineageOS’s GitHub organization <https://github.com/LineageOS>`_. This is done by typing your device’s codename into the search box. The device repository follows the naming convention: android_device_[manufacturer]_[device]. Make a note of this name."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:40
#: ../../porting/build_and_boot/H9_setup_sources.rst:40
msgid "Open the device repository on Github. It will contain a ``lineage.dependencies`` (or ``cm.dependencies``) file which specifies all other repositories that your device is reliant upon."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:46
#: ../../porting/build_and_boot/H9_setup_sources.rst:46
msgid "Creating the device manifest file"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:48
#: ../../porting/build_and_boot/H9_setup_sources.rst:48
msgid "Now create (or edit) the file ``BUILDDIR/halium/devices/manifests/[manufacturer]_[device].xml``. (The description below presupposes that you are creating the file from scratch.)"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:50
#: ../../porting/build_and_boot/H9_setup_sources.rst:50
msgid "Paste the following into the file::"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:58
#: ../../porting/build_and_boot/H9_setup_sources.rst:58
msgid "The device repository"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:60
msgid "Your sources must now be entered into the manifest. Start with your device repository. Between the <manifest> and </manifest> tags, create the line below, making sure to replace the information inside the square brackets with your own::"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:64
#: ../../porting/build_and_boot/H9_setup_sources.rst:64
msgid "'path' specifies the target path (subdirectory of your BUILDDIR) where the source code from repository 'name', which is found at 'remote', will be placed. The repository may contain a number of branches and it is important to secure the correct branch with 'revision='"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:67
#: ../../porting/build_and_boot/H9_setup_sources.rst:67
msgid "The revision attribute may be omitted if the default revision for this remote is the one that you wish to use."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:69
msgid "If you are unsure of your remote, refer to :ref:`H7_remotes`."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:72
#: ../../porting/build_and_boot/H9_setup_sources.rst:72
msgid "Dependencies"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:74
#: ../../porting/build_and_boot/H9_setup_sources.rst:74
msgid "Now create more lines like the previous one, using the ``lineage.dependencies`` (or ``cm.dependencies``) file you found earlier in your device repository. This file lists all the remaining repositories needed to build for your selected device. Create one line for each entry in this file, using the following template::"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:78
msgid "The target path is found in the repository’s name. The preceding “android” or “proprietary” is omitted and underscores are replaced with slashes. For example, ``android_device_lge_bullhead`` goes in ``device/lge/bullhead``."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:81
#: ../../porting/build_and_boot/H9_setup_sources.rst:81
msgid "Vendor blobs"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:83
msgid "Vendor blobs go in the ``vendor/`` folder of your ``BUILDDIR``."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:85
#: ../../porting/build_and_boot/H9_setup_sources.rst:85
msgid "The first place to search for your device’s vendor blobs is in `'TheMuppets' GitHub organization <https://github.com/TheMuppets>`_. Enter your device’s codename into the search field and see if you get a match. If you are unable to find your device in TheMuppets, you will need to search elsewhere."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:87
#: ../../porting/build_and_boot/H9_setup_sources.rst:87
msgid "It may also be possible to extract the vendor blobs from the device itself by following instructions for your device on `the LineageOS wiki <https://wiki.lineageos.org/>`_ as applicable."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:92
#: ../../porting/build_and_boot/H9_setup_sources.rst:92
msgid "Remotes"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:94
#: ../../porting/build_and_boot/H9_setup_sources.rst:94
msgid "A remote entry specifies the name, location (fetch) prefix, code review server, and default revision (branch/tag) for the source."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:96
msgid "You can create a remote by adding a remote tag to your manifest as shown in the following example::"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:103
#: ../../porting/build_and_boot/H9_setup_sources.rst:105
msgid "Only the name, fetch, and revision attributes are required. The review attribute specifies a Gerrit Code Review server, which probably won’t be useful for initial porting purposes."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:105
msgid "For example, let’s say that you have a bunch of repositories at https://github.com/SomeUserName/ and your desired branch name is los-14.1 in each. You would create a remote as follows and place it into your local manifest::"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:111
msgid "There are also some remotes available to you by default, though they differ between Halium versions. The following tables will help you identify these. See more information on these remotes can be found at the top of the file ``BUILDDIR/halium/.repo/manifests/default.xml``."
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:113
msgid "The following remotes are available by default in Halium 7.1:"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:116
#: ../../porting/build_and_boot/H9_setup_sources.rst:118
msgid "Remote Name"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:116
#: ../../porting/build_and_boot/H9_setup_sources.rst:118
msgid "Remote Description, URL"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:118
#: ../../porting/build_and_boot/H9_setup_sources.rst:122
msgid "aosp"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:118
#: ../../porting/build_and_boot/H9_setup_sources.rst:122
msgid "Android Open Source Project, https://android.googlesource.com"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:119
msgid "los"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:119
msgid "LineageOS, http://github.com/LineageOS"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:120
msgid "hal"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:120
msgid "Halium (link to GitHub root for legacy reasons), http://github.com"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:121
msgid "them"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:121
msgid "TheMuppets, http://github.com/TheMuppets"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:122
msgid "them2"
msgstr ""

#: ../../porting/build_and_boot/H7_setup_sources.rst:122
msgid "TheMuppets (for some xiaomi vendor repos) https://gitlab.com/the-muppets"
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:2
msgid "Halium-9.0 - Building"
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:4
msgid "When doing a Halium 9.0 port, you first need to build ``halium-boot.img``. This boot image can then either be combined with the GSI, or you can build your own, device-specific ``system.img`` as well."
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:7
msgid "Building the boot image (halium-boot.img)"
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:12
msgid "First you need to initialize the environment using the ``envsetup.sh`` tool included in your source tree. Enter your ``BUILDDIR`` and issue the command::"
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:16
msgid "The output should resemble this::"
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:24
msgid "The ``breakfast`` command is used to set up the build environment for a specific device. From the root of your ``BUILDDIR`` run the following command, replacing [CODENAME] with your device's specific codename::"
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:39
msgid "Then, from the root of your ``BUILDDIR``, run::"
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:68
msgid "Setting system as root"
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:70
msgid "For Halium 9, we need the system image to be built as system-as-root (for treble devices it should already be there). Please check your ``boardconfig.mk`` for the following line, if it's there you can skip this step::"
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:74
msgid "If the above is not there, we have to add it."
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:76
msgid "As this change makes the android root read-only, we may have to ship mount points for some important partitions like ``firmware``, ``persist`` with the system image, for this we can use the line::"
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:84
msgid "For now this is enough, but you may need to add more mount points depending on your device. After successful boot do ``ls -la /`` and add folders corresponding to broken symlinks."
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:86
msgid "These changes may also bring in some context errors,please refer `this commit to fix them <https://github.com/gigabyte-1000/android_device_xiaomi_kenzo/commit/3e8ea1e3194c19aa52b0b2618df249d4b1076dca#diff-30b9d15aecb84fc004f83370d35234b955cff4d0640892fe60e3c4a422ae3e3d>`_."
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:92
msgid "Halium will use the ``mkbootimg`` tool for creating the boot image. In most cases it is not on the local harddisk, so it can be built by issuing::"
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:110
msgid "If your particular error is not listed, you will need to do some research of your own. If you end up here, know that there is a community of porters, developers and enthusiasts who might be able to help you. Refer to :ref:`Getting-community-help`."
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:117
msgid "If you are using the **Halium-boot** method, you can skip this step. If you are following the **Full system image** method, this step is required."
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:120
msgid "Halium will use the ``e2fsdroid`` tool for creating the system image. In most cases it is not on the local harddisk, so it can be built by issuing::"
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:125
msgid "To build the system image::"
msgstr ""

#: ../../porting/build_and_boot/H9_build.rst:129
msgid "It's likely that you will run into one or more errors when building the system image. A number of possible errors and known solutions are documented in `the Halium guide <https://docs.halium.org/en/latest/porting/common-system-build-errors.html#common-system-build-errors>`_. If yours is not listed, :ref:`seek community help <Getting-community-help>`."
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:2
msgid "Halium-9.0 - Setting up the sources"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:5
msgid "Initializing and downloading the Halium source"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:13
msgid "First, initialize your source to the correct version of Halium, depending on your device. If in doubt, refer to :ref:`Android-and-Halium-versions`."
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:15
msgid "For Halium 9.0::"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:19
msgid "With the Halium tree initialized you are ready to download the code by issuing the command::"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:60
msgid "Your sources must now be entered into the manifest. Start with your device repository. Between the ``<manifest>`` and ``</manifest>`` tags, create the line below, making sure to replace the information inside the square brackets with your own::"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:69
msgid "If you are unsure of your remote, refer to :ref:`H9_remotes`."
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:78
msgid "The target path is found in the repository’s name. The preceding “android” or “proprietary” is omitted and underscores are replaced with slashes. For example, android_device_lge_bullhead goes in device/lge/bullhead."
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:83
msgid "Vendor blobs go in the vendor/ folder of your BUILDDIR."
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:96
msgid "You can create a remote by adding a remote tag to your manifest::"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:103
msgid "(Note: The above is merely an example and cannot be used as such for Halium-9.0)"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:107
msgid "For example, let’s say that you have a bunch of repositories at https://github.com/SomeUserName/ and your desired branch name is los-16.0 in each. You would create a remote as follows and place it into your local manifest::"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:113
msgid "There are also some remotes available to you by default, though they differ between Halium versions. The following tables will help you identify these. See more information on these remotes can be found at the top of the file BUILDDIR/halium/.repo/manifests/default.xml."
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:115
msgid "The following remotes are available by default in Halium 9.0:"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:120
msgid "github"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:120
msgid "LineageOS, https://github.com/"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:121
msgid "gitlab"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:121
msgid "Gitlab, https://about.gitlab.com/"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:125
msgid "If you do not specify a remote, aosp is assumed."
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:128
msgid "Sync and apply hybris patches"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:130
msgid "With your manifest now complete, go to the root of your ``BUILDDIR`` and issue the following command (replace DEVICE with your device’s codename) to bring the device-specific source code into your source tree::"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:134
msgid "This will first link your manifest from Halium devices to ``.repo/local_manifests/device.xml`` and then sync all repositories."
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:136
msgid "Once complete you can now run a script to apply hybris patches. These are mainly used for building the system image and can be omitted if your goal is to only build ``halium-boot.img``. However, if you run into build errors, it might be worthwhile to try applying these patches all the same."
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:138
msgid "From the root of your BUILDDIR, run the following command::"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:143
msgid "Document"
msgstr ""

#: ../../porting/build_and_boot/H9_setup_sources.rst:145
msgid "After completing the relevant steps above (according to your chosen, create a pull request containing your device manifest on the Halium devices repository. Also, create a device page on the UBports page under devices. You should link the manifest on Halium devices in your UBports device page."
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:2
msgid "Installing Halium-based builds"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:4
msgid "With the necessary compontents built, you are now ready to install them on your device and check whether they function as intended. There are only minor differences between Halium versions when it comes to the installation process. In all cases, the system image and rootfs are installed together on the userdata partition of the device. This is done for practical reasons, as it makes the installation process simpler to manage during the first phases of the porting process. Once the port reaches the level of maturity required for it to be offered through the UBports installer (see :ref:`Finalize`), this must be changed in order to reserve a maximum of possible space for userdata."
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:6
msgid "In brief:"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:8
msgid "**Halium-7.1** requires installing the boot image and system image you have built, together with the UBports rootfs, which you need to download."
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:9
msgid "**Halium-9.0 and newer** require installing the boot image you have built together with the GSI and the UBports rootfs. Both the GSI and the rootfs are available for download. Note: If you chose to build your own system.img, then you must use this instead of the GSI when installing."
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:11
msgid "In order to install Ubuntu Touch, you need a recovery image with Busybox, such as TWRP, installed on your phone. If you have not done so yet, refer to section :ref:`Install-TWRP-recovery` and install it now."
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:13
msgid "You will also need to ensure the ``/data`` partition is formatted with ``ext4`` and is not encrypted. Boot into recovery, check and adjust as necessary."
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:18
msgid "Flashing halium-boot.img"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:20
msgid "To install halium-boot, reboot your phone into fastboot mode. Then do the following from the root of your ``BUILDDIR``::"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:25
msgid "If you have trouble accessing your device in fastboot mode, but are able to access it in TWRP recovery mode using adb, then boot into recovery mode and try the following alternative method::"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:30
msgid "On your device, choose *Install* in the TWRP menu, navigate to the ``/tmp`` directory, choose *Image*, select your image file, select *Boot* and swipe to flash."
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:33
msgid "Samsung devices: Flashing halium-boot.img on Samsung devices is done using the Heimdall flashing utility (on Linux) or the Odin utility (on Windows) after first bringing the device into 'download mode'. See more information on these utilities `here <http://docs.halium.org/en/latest/porting/install-build/reference-rootfs.html#install-hybris-boot-img-on-samsung-devices>`_. Follow the instructions for the utility you choose, including the specific flashing command for flashing the boot partition. Install system.img and rootfs (below) with the device in recovery mode."
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:38
msgid "Installing system image and rootfs"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:40
msgid "**Read carefully** and perform only the steps which apply to your Halium version and the files you will be flashing!"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:43
msgid "Download the appropriate rootfs"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:45
msgid "Start by downloading the appropriate rootfs for your device. You need a rootfs corresponding to your device's architecture and the Halium version you have built. At the moment there are two available versions for Halium 7.1, an armhf (32 bit) version and an arm64 (64 bit) version. For Halium 9.0 there is only an arm64 rootfs available. Follow the appropriate link below to download the one you need."
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:47
msgid "Halium 7.1, armhf (32 bit): `ubports-touch.rootfs-xenial-armhf.tar.gz <https://ci.ubports.com/job/xenial-rootfs-armhf/>`_"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:48
msgid "Halium 7.1, arm64 (64 bit): `ubuntu-touch-hybris-xenial-arm64-rootfs.tar.gz <https://ci.ubports.com/job/xenial-hybris-rootfs-arm64/>`_"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:49
msgid "Halium 9.0, armhf (32 bit): `ubuntu-touch-android9-armhf.tar.gz <https://ci.ubports.com/job/xenial-hybris-android9-rootfs-armhf/>`_"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:50
msgid "Halium 9.0, arm64 (64 bit): `ubuntu-touch-android9-arm64.tar.gz <https://ci.ubports.com/job/xenial-hybris-android9-rootfs-arm64/>`_"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:53
msgid "Download the halium-install script"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:55
msgid "Clone or download the `halium-install repository <https://gitlab.com/JBBgameich/halium-install>`_. This repository contains tools that can be used to install a Halium system image and distribution rootfs. Reboot your device to recovery (e.g. TWRP), to get adb access again. Now use the ``halium-install`` script to install Ubuntu Touch on your device."
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:59
msgid "Perform the installation"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:61
msgid "For **Halium 7.1 ports** use the following command::"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:65
msgid "For **Halium 9.0 ports**, use this command::"
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:69
msgid "where [SYSTEM_IMAGE] will be the file ``android-rootfs.img`` you downloaded and extracted, or alternatively the file ``system.img`` you built yourself."
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:71
msgid "The script will copy and extract the files to their proper places, then allow you to set the user password for your device (the *phablet* user's password)."
msgstr ""

#: ../../porting/build_and_boot/Halium_install.rst:74
msgid "halium-install might fail due to unconfigured bintfmt-support for qemu throwing errors such as 'chroot: failed to run command ‘passwd’: Exec format error'.    To fix this, ``/proc/sys/fs/binfmt_misc/register`` should be updated. `binfmt-manager <https://github.com/mikkeloscar/binfmt-manager>`_ by `@mikkeloscar <https://github.com/mikkeloscar/>`_ can provide quickfix."
msgstr ""

#: ../../porting/build_and_boot/index.rst:2
msgid "Building and booting"
msgstr ""

#: ../../porting/build_and_boot/index.rst:4
msgid "Now it's time to download and configure the necessary source code. Then we'll build it and get it to boot. Firstly follow the **Building** steps for your Halium version and porting method. Secondly, proceed with the final **Install and boot** section."
msgstr ""

#: ../../porting/build_and_boot/index.rst:11
msgid "Building"
msgstr ""

#: ../../porting/build_and_boot/index.rst:14
msgid "Full system image method or Halium-boot method"
msgstr ""

#: ../../porting/build_and_boot/index.rst:16
msgid "If you are using either of the **Full system image** method (for Halium 7.1 or 9.0), or the **Halium-boot** method (for Halium 9.0), then please pick the two steps below matching your Halium version."
msgstr ""

#: ../../porting/build_and_boot/index.rst:29
#: ../../porting/introduction/Intro.rst:89
msgid "Standalone kernel method"
msgstr ""

#: ../../porting/build_and_boot/index.rst:31
msgid "If you are using the **Standalone kernel** method, then please pick the step below."
msgstr ""

#: ../../porting/build_and_boot/index.rst:39
msgid "Install and boot"
msgstr ""

#: ../../porting/build_and_boot/index.rst:41
msgid "Afterwards, proceed with these steps for any porting method."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:4
msgid "Standalone Kernel Method (Halium 9 and newer)"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:6
msgid "Starting from Halium 9, it is possible to port a device using only the kernel. This involves a number of scripts that build the kernel, download the generic container image and rootfs, and create flashable images."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:8
msgid "This guide expects you to have some mandatory git knowledge, like cloning and pushing, and creating repos."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:11
msgid "Setting up your build environment"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:14
msgid "Assuming you have already installed the tools specified in the section on :ref:`Setting-up`, there are just a few more to add before your build environment is complete. Run this commmand to add them::"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:20
msgid "If you use a RPM based distro such as Mageia, you run::"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:27
msgid "Setting up and configuring a device source"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:30
msgid "Creating the device source"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:32
msgid "Clone an existing repo for a device from https://gitlab.com/ubports/community-ports. Ideally choose a device with similar SoC/Android version as base."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:34
msgid "deviceinfo contains the configuration used during device build process (kernel, boot, dtb/dtbo if needed + recovery on later porting stages). To craft your own deviceinfo, follow the guide further."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:37
msgid "Getting device kernel source code"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:39
msgid "First thing to check is if  your device has an official or unofficial LineageOS port, as the porter may have already done the cleaning up bits needed for the device vendor kernel sources or incorporated out-of-tree kernel modules back into kernel tree, which makes life easier for us."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:41
msgid "If not, check if device manufacturer provides kernel source at all: ASUS, Lenovo, Samsung, ZTE usually provide kernel source code tarballs at their website. Motorola, Realme, OnePlus, Xiaomi usually upload kernel source to their official GitHub account."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:45
msgid "After you have acquired the kernel source, you need to upload it somewhere else for making modifications and commits for Ubuntu Touch. GitLab is preferred since when you'll get the port pulled into the UBports org, it can be easily copied from there."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:48
msgid "Finding your correct kernel config"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:50
msgid "There are two ways to find your correct kernel config, naming some below: 1. Getting your config on device from /proc/config.gz 2. Getting your defconfig in kernel source"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:55
msgid "Getting your config from device"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:57
msgid "It is possible to pull your current kernel config from device, if the configuration is present as ``/proc/config.gz`` on device. To pull this config, copy the ``/proc/config.gz`` file from your device to your computer. Then, run ``zcat`` on the file to get its output. Save this as ``.config`` in your kernel source. After this, run ``ARCH=<your device's architecture> make savedefconfig``, which will convert your fully fledged config into a defconfig. Copy ``defconfig`` to ``arch/<your device's architecture>/configs/<your device's codename_defconfig``."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:62
msgid "Proceed with the guide to patch your config."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:65
msgid "Getting your defconfig in kernel source"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:67
msgid "In order to find your defconfig from kernel source, you will have to search for it in the ``arch/<your device's architecture/configs`` directory. This defconfig can be named in numerous ways, like ``<your device's codename>_defconfig``, or something weird like ``k61v64_debug_defconfig``. If you got your kernel source from an OEM, sometimes it includes a ``build.sh`` script which references the defconfig required. Otherwise if you got your kernel source from somewhere like LineageOS, their device tree's reference the defconfig too."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:72
msgid "After finding your defconfig, proceed with the guide to patch it."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:76
msgid "Applying minimal patches to your defconfig"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:78
msgid "In order for Ubuntu Touch to successfully boot, we need to enable some configs required by the OS. Start by browsing into your kernel directory, and into the ``arch/<your device's architecture>/configs``, where you will have to add a new file called ``halium.config``. In this file, add the following content:"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:82
msgid "CONFIG_DEVTMPFS=y"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:83
msgid "CONFIG_FHANDLE=y"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:84
msgid "CONFIG_SYSVIPC=y"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:85
msgid "CONFIG_IPC_NS=y"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:86
msgid "CONFIG_NET_NS=y"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:87
msgid "CONFIG_PID_NS=y"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:88
msgid "CONFIG_USER_NS=y"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:89
msgid "CONFIG_UTS_NS=y"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:90
msgid "CONFIG_VT=y"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:92
msgid "After this, save and close this file. Commit it into your kernel repo if you wish, because this config name will be added in deviceinfo."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:94
msgid "At this point you've almost completed the initial setup for the kernel, move on to configuring ``deviceinfo`` and building."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:96
msgid "After you have booted the OS successfully, you can move on to patching the defconfig fully in later stages."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:99
msgid "Filling in your deviceinfo"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:101
msgid "Full device name, like Redmi 9C or Redmi Note 10S. Replace as necessary."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:103
msgid "``deviceinfo_name=\"Redmi 9C\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:106
msgid "The name of the device's manufacturer. Change as needed."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:108
msgid "``deviceinfo_manufacturer=\"Xiaomi\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:111
msgid "The codename of the phone. This can be obtained by googling for it like: \"<device name> codename\". Replace device name with your phone's full name. Replace the codename below with your own too."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:113
msgid "``deviceinfo_codename=\"angelica\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:116
msgid "The architecture of your kernel. Most devices released after 2015 have an ARM64 CPU, but some oddities in between can still be armhf. For ARM64 devices, set the config to \"aarch64\". For armhf devices, set the config to \"armv7\"."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:118
msgid "``deviceinfo_arch=\"aarch64\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:121
msgid "This defines the git repo where your kernel is located. You already should have this link at hand if you followed section 1, if not go through it again. Replace below link with your own."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:123
msgid "``deviceinfo_kernel_source=\"https://github.com/muhammad23012009/android_kernel_xiaomi_dandelion\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:126
msgid "The branch of the kernel comes next. This can be easily obtained by looking at the tab under the Code tab on GitHub or the tab on the top left side in GitLab. Replace as necessary."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:128
msgid "``deviceinfo_kernel_source_branch=\"halium10-new\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:131
msgid "Defconfig is a vital part of the kernel compilation process. Most of the times you can find this defconfig in your kernel source, the path to which is \"arch/<your architecture>/configs\". The defconfig's name is often built up like \"<your codename>_defconfig\". After finding your defconfig, replace it as necessary. You also need to add ``halium.config`` in this field, due to adding the kernel config patches above. (If you still can't find the defconfig refer to section \"Finding your defconfig\")"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:135
msgid "``deviceinfo_kernel_defconfig=\"angelica_defconfig halium.config\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:138
msgid "The kernel cmdline is one of the key things that is required to make the kernel boot. It has special parameters that allow the kernel to determine which features/things need to be enabled, and which need to be disabled. The Ubuntu Touch rootfs also relies on some key cmdlines which is required to boot, most specifically \"console=tty0\". To adapt this to your device, try unpacking your boot image (section 8.3) and copying the cmdline from there, or take the help of a LineageOS device tree if it is available. \"console=tty0\" is a must for cmdline and should not be removed no matter what. Rest of the things can be removed and you can adjust these to your device. ``console=tty0`` is a requirement for the rootfs to properly boot. ``systempart`` is added if you want to boot your rootfs from your system partition. It is supposed to point to your system partition."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:141
msgid "``deviceinfo_kernel_cmdline=\"console=tty0 bootopt=64S3,32N2,64N2 systempart=/dev/mapper/system\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:144
msgid "Add this to your deviceinfo if you wish to compile your kernel with clang. Most devices released with and after Android 10 build their kernels with clang. If you don't want to build with clang, omit this entry entirely."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:146
msgid "``deviceinfo_kernel_clang_compile=\"true\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:149
msgid "Only required if you wish to use LLD as your linker and enable LTO. For most old kernels LTO is broken. If you do want to use it add this entry to your deviceinfo, else omit it."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:152
msgid "``deviceinfo_kernel_use_lld=\"true\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:155
msgid "This config allows you to compile your kernel with LLVM and LTO, granted that it's supported by it. This is a neat way of specifying ``clang`` and ``ld.lld`` together. Usually needed by GKI devices. (Once enabled, you do not needed to specify ``deviceinfo_kernel_use_lld``)"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:160
msgid "``deviceinfo_kernel_llvm_compile=\"true\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:163
msgid "Use this to enable 'dtc_ext' for compiling your dtb/dtbo's. Use only if you know what you're doing. The default compiler works most of the times."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:165
msgid "``deviceinfo_kernel_use_dtc_ext=\"true\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:168
msgid "Use this option to specify the kernel image name after kernel compiles. More than often this option is simply not required, so you can drop it from your deviceinfo. If you do need it, adjust image name as necessary."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:170
msgid "``deviceinfo_kernel_image_name=\"Image.gz\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:173
msgid "In order to specify your ramdisk compression algorithm, use the below option. It is set to gzip by default. Mostly useful for GKI devices."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:176
msgid "``deviceinfo_ramdisk_compression=\"lz4\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:179
msgid "Add this option to specify your Halium version. Up to Halium 13 is supported at this moment."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:181
msgid "``deviceinfo_halium_version=\"11\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:184
msgid "This option defines the boot image header version. It is important you get this right, else your device may not boot. Devices launching with Android versions below 8 (Oreo) use header 0, Android 9 (Pie) uses version 1, Android 10 uses version 2, and GKI devices use version 3/4 (depending on Android version which they were released, Android 12 with GKI uses version 4)."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:186
msgid "``deviceinfo_bootimg_header_version=\"2\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:189
msgid "Use this option to define a prebuilt dtb that you have sourced. Path is relative to your directory where you are editing the deviceinfo file. Edit the dtb name according to what you have. If your header version is greater than or equal to 3 (GKI device), this will include dtb in your vendor_boot."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:192
msgid "``deviceinfo_bootimg_prebuilt_dtb=\"mt6765.dtb\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:195
msgid "This option uses the dtb's created by your kernel while compiling, multiple dtb's can be specified here like: \"mediatek/mt6765.dtb mediatek/angelica.dtb\" The path in which the scripts look for the dtb's with this option enabled is \"KERNEL_OBJ/arch/<architecture>/boot/dts\" where <architecture> will either be arm64 or arm depending on what you set in deviceinfo_arch (aarch64 is arm64 in kernel speak) If your header version is greater than or equal to 3 (GKI device), this will include dtb in your vendor_boot."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:200
msgid "``deviceinfo_dtb=\"mediatek/mt6765.dtb\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:203
msgid "Selecting this will build a DT image that you selected into the boot image. Path is relative to your current directory in which you're editing deviceinfo. (Note: This is only really required in Samsung/Exynos devices.)"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:205
msgid "``deviceinfo_bootimg_prebuilt_dt=\"exynos8890-dt.img\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:208
msgid "Use this to ship a prebuilt dtbo in your OTAs and to build your recovery with this dtbo if it isn't already being compiled. Path is once again relative to your build directory. Edit as desired."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:210
msgid "``deviceinfo_prebuilt_dtbo=\"angelica-dtbo.img\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:213
msgid "In case you do not want to ship the DTBO image in an OTA, selecting this will only remove the dtbo from the OTA package but recovery will still be compiled with this dtbo, if dtbo isn't already being compiled."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:215
msgid "``deviceinfo_skip_dtbo_partition=\"true\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:218
msgid "If you want to compile your DTBO from kernel, use this option to select the dtbo files compiled in kernel out directory. The path in which this option will search is KERNEL_OBJ/arch/<architecture>/boot/dts. Multiple dtbo's can be supplied like shown in the example. Adapt the names as per your requirements. The resulting dtbo image will be shipped in the OTA if the skip_dtbo_partition option isn't selected, and in any case recovery will also be built with this dtbo. This option is incompatible with the prebuilt dtbo option."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:221
msgid "``deviceinfo_dtbo=\"mediatek/galahad.dtbo mediatek/lancelot.dtbo\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:224
msgid "Using this will define the board name in your boot image, which some bootloaders require to boot the image successfully. Only use this option if your stock boot image has this flag set in its header. Edit as you wish if necessary."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:226
msgid "``deviceinfo_bootimg_board=\"EXYNOS4412\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:229
msgid "Use this option to pad your boot image to a specific size. Also required if you want to append a vbmeta image or append a hash footer to your image. Change the size to your stock boot image size. (Note: The size is declared in bytes)."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:231
msgid "``deviceinfo_bootimg_partition_size=\"67713847\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:234
msgid "Pretty self-explanatory. Set it to true if your device requires a vbmeta image appended (Not the case for most devices with a dedicated vbmeta partition.)"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:236
msgid "``deviceinfo_bootimg_append_vbmeta=\"true\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:239
msgid "Use this option when you want to create a recovery.img for booting UBports recovery (Only really required when you're finalizing the port). In most cases you'll want to omit this in the start of your port and add it as you try to get it in installer. Setting to true builds the recovery and setting to false or omitting the entry entirely will cause it to not build at all."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:241
msgid "``deviceinfo_has_recovery_partition=\"true\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:244
msgid "Use this to pad your recovery image to a specific size. Also a requirement if you want to add a hash footer to your image. Replace the size from your stock recovery image. (Will only work if you're building recovery!)"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:246
msgid "``deviceinfo_recovery_partition_size=\"67713847\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:249
msgid "This is only really required for some old/new Samsung that check for an \"SEAndroid\" footer on their boot images to check whether or not the boot images are official. If the bootloader doesn't find it it results in an ugly looking red line on the top of the screen. Adding this to your deviceinfo will append this string to the boot image. (Beware! Using this on other devices may cause it to not boot the image!)"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:251
msgid "``deviceinfo_bootimg_tailtype=\"SEAndroid\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:254
msgid "This config determines whether modules should be compiled and installed into rootfs or not. Omitting this config results in the default behaviour, i.e., modules get compiled and installed into rootfs. Adding this option to your deviceinfo and setting it to true (like shown) will disable modules compilation. Only really needed in case you're doing something advanced."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:256
msgid "``deviceinfo_kernel_disable_modules=\"true\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:259
msgid "This option installs all overlay files (in overlay/ directory) into /system/opt/halium-overlay, therefore overlaying the files onto the files present in rootfs instead of completely replacing them. This is necessary for 20.04 and onwards, but not applicable for 16.04."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:261
msgid "``deviceinfo_use_overlaystore=\"true\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:264
msgid "This option is mostly used on some Qualcomm devices. Adding this to your deviceinfo will combine all your dtbo's with your dtbs. Only use if you are sure you need this."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:266
msgid "``deviceinfo_kernel_apply_overlay=\"true\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:269
msgid "Add this configuration to your deviceinfo when you need to specify a fixed size for your rootfs being flashed to system image. Default is 3000M when option is not set. Only use if you need it."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:271
msgid "``deviceinfo_system_partition_size=\"4000M\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:274
msgid "This config is only relevant for newer devices launched with UFS storage"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:276
msgid "``deviceinfo_rootfs_image_sector_size=\"4096\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:279
msgid "Next up are flash offsets. You can ignore these if you're building only boot.img for a GKI device, but are required if you want to build vendor_boot.img. These offsets will automatically apply for vendor_boot if your header version is greater than or equal to 3. A guide to extract them is as follows:"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:283
msgid "Extracting values from stock boot.img/vendor_boot.img"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:285
msgid "For any port to boot, some values must be pulled from the stock boot.img. First and foremost, try to get your stock firmware. Some manufacturers like Samsung like to encrypt their firmwares, but still some tools are available to get them. Others like Xiaomi provide the firmware, but you need to use Google to search it. And then there's the good guy Google, who provide full firmware binaries easily accessible. Long story short, you need to at least find your stock firmware, and then get the boot.img. Once you have the boot.img acquired, follow the following steps:"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:288
msgid "Make a directory in which you'll store all your unpacked data. It can be anywhere, and can have any name. For now, we'll call it `temp`."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:290
msgid "Run \"mkdir ~/temp\" to create the directory and \"cd ~/temp\" to go to it."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:292
msgid "Now to unpack the boot image there are several utilities to do so. One of them is the python script provided by Android. For now we'll use this. To download it into your current working directory run \"wget https://raw.githubusercontent.com/LineageOS/android_system_tools_mkbootimg/lineage-19.1/unpack_bootimg.py\" This will download the unpack_bootimg.py script, which you'll now use to pull your kernel offsets and other values alike"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:294
msgid "Bring your boot.img into the temp directory."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:296
msgid "Now run the script. The usual syntax is \"python3 unpack_bootimg.py --boot_img <boot.img or vendor_boot.img> --out out\" This will unpack the boot image, store the output files in the out directory, and it will also print the offsets on screen."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:299
msgid "A sample output for boot.img will look like this:"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:301
msgid "boot magic: ANDROID!"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:303
msgid "kernel_size: 11399060"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:305
msgid "kernel load address: 0x40080000"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:307
msgid "ramdisk size: 6576255"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:309
msgid "ramdisk load address: 0x51b00000"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:311
msgid "second bootloader size: 0"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:313
msgid "second bootloader load address: 0xc0ff0000"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:315
msgid "kernel tags load address: 0x47880000"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:317
msgid "page size: 2048"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:319
msgid "os version: 10.0.0"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:321
msgid "os patch level: None"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:323
msgid "boot image header version: 2"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:325
msgid "product name:"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:327
msgid "command line args: bootopt=64S3,32N2,64N2 buildvariant=user systempart=/dev/mapper/system:ro"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:329
msgid "additional command line args:"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:331
msgid "recovery dtbo size: 0"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:333
msgid "recovery dtbo offset: 0x0000000000000000"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:335
msgid "boot header size: 1660"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:337
msgid "dtb size: 216417"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:339
msgid "dtb address: 0x0000000047880000"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:342
msgid "whereas for vendor_boot.img, will look like this:"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:344
msgid "boot magic: VNDRBOOT"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:346
msgid "vendor boot image header version: 4"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:348
msgid "page size: 0x00001000"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:350
msgid "kernel load address: 0x10008000"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:352
msgid "ramdisk load address: 0x10000000"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:354
msgid "vendor ramdisk total size: 13685168"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:356
msgid "vendor command line args: bootconfig loop.max_part=7"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:358
msgid "kernel tags load address: 0x10000000"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:360
msgid "product name: SRPUK23A007"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:362
msgid "vendor boot image header size: 2128"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:364
msgid "dtb size: 231604"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:366
msgid "dtb address: 0x0000000011f00000"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:368
msgid "vendor ramdisk table size: 216"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:370
msgid "vendor bootconfig size: 28"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:373
msgid "Here's where this will get interesting."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:375
msgid "\"kernel load address\" is the kernel offset. The value after the colon is what you need, for example,   0x40080000. This will be different in your case."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:377
msgid "\"ramdisk load address\" will be your ramdisk offset. Take the value next to it. For example, 0x51b00000."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:379
msgid "\"second bootloader load address\" is mostly unnecessary by today's standards. But if your boot image does spit this value, make sure to take it. For example, 0xc0ff0000."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:381
msgid "\"kernel tags load address\" is a special one. It's used for both kernel tags and dtb, but in some cases these values can be different. Take the value as well. For example, 0x47880000."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:383
msgid "\"dtb address\" is sometimes the same as \"kernel tags load address\". But if it's different, you should use this for dtb and tags for tags."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:385
msgid "\"page size\" is required for the ramdisk to know what your flash chip uses for page sizes. Value after colon is what you need. For example, 2048."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:387
msgid "\"os version\" is the value which determines which Android version this boot.img has. Some bootloaders enforce this. For example, 10.0."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:389
msgid "\"os patch level\" is a similar story. You'll also want to grab this value, for example, 2021-11."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:391
msgid "\"command line args\" go straight into deviceinfo_kernel_cmdline. Make sure to keep \"console=tty0\" in there. No examples here :("
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:393
msgid "If you're building vendor_boot, this command will also output a ``bootconfig`` file in your output directory. Move this to your source tree's root."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:395
msgid "Apart from these mentioned values, you'll want to skip everything else."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:398
msgid "Now according to said guide, fill in your offsets:"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:401
msgid "Put the value from \"page size\" into this config."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:403
msgid "``deviceinfo_flash_pagesize=\"2048\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:406
msgid "Base offset will always remain 0x00000000."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:408
msgid "``deviceinfo_flash_offset_base=\"0x00000000\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:411
msgid "Fill this in from \"kernel load address\"."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:413
msgid "``deviceinfo_flash_offset_kernel=\"0x40080000\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:416
msgid "This gets its value from \"ramdisk load address\"."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:418
msgid "``deviceinfo_flash_offset_ramdisk=\"0x51b00000\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:421
msgid "Although not mission critical, if you did get its value, fill it in from \"second bootloader load address\"."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:423
msgid "``deviceinfo_flash_offset_second=\"0xc0ff0000\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:426
msgid "Tags should be filled in from \"kernel tags load address\"."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:428
msgid "``deviceinfo_flash_offset_tags=\"0x47880000\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:431
msgid "DTB offset comes from \"dtb load address\"."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:433
msgid "``deviceinfo_flash_offset_dtb=\"0x47880000\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:436
msgid "This comes from \"os version\". Not exactly required but some OEMs enforce it."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:438
msgid "``deviceinfo_bootimg_os_version=\"10.0\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:441
msgid "You'll want to put the \"os patch level\" value here."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:443
msgid "``deviceinfo_bootimg_os_patch_level=\"2021-11\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:446
msgid "If you're building a vendor_boot and you have moved the ``bootconfig`` file to your tree's root, add the following:"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:448
msgid "``deviceinfo_vendor_bootconfig_path=\"bootconfig\"``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:451
msgid "And just like that, you've filled in your deviceinfo properly and can now get on with the port!"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:455
msgid "Building, installing and running"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:457
msgid "After you've completed your deviceinfo and filled in all needed stuff, its time you get to the main part, the build. For this just run: ``./build.sh -b workdir``"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:460
msgid "That should download all the needed toolchains and then the kernel, and finally build everything. This process may take about 5 to 50 minutes to build the kernel."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:462
msgid "After your kernel is done building, you will have to build the rootfs. For this, just execute this:"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:464
msgid "``./build/prepare-fake-ota.sh out/device_<your device's codename>_usrmerge.tar.xz ota`` This will download the rootfs, extract it and pack it into tarballs for our final script to create flashable images."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:467
msgid "Next up, run:"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:469
msgid "``./build/system-image-from-ota.sh ota/ubuntu_command images`` This will convert the tarballs into flashable images, and your images will be stored in the `images/` directory. There will be a number of files depending on how you configured your deviceinfo. But the basic file structure will be as given:"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:473
msgid "images/"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:474
msgid "├── boot.img"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:475
msgid "├── rootfs.img"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:476
msgid "└── system.img"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:479
msgid "The ``boot.img`` will be flashed onto the boot partition of the phone. The ``system.img`` and ``rootfs.img`` are interchangable. ``rootfs.img`` is pushed to the data partition as ``ubuntu.img`` if you didn't include ``systempart`` in deviceinfo's cmdline. Otherwise, ``system.img`` is flashed to your system partition."
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:484
msgid "Notes"
msgstr ""

#: ../../porting/build_and_boot/standalone_kernel_build.rst:486
msgid "For a lot of kernel-related commands, you'll need the ARCH variable's value, this is either arm or arm64 depending on where you found your defconfig. A thing to keep in mind for kernel patches."
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:5
msgid "AppArmor"
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:7
msgid "Without AppArmor a number of device features will not function properly and most apps will crash when launched. For more information on AppArmor, refer to the `Ubuntu Wiki. <https://wiki.ubuntu.com/AppArmor>`_"
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:9
msgid "AppArmor is added through a combination of integrating the necessary code into the kernel source tree and setting necessary kernel configuration. The process is slightly different on Halium-7.1, compared to newer Halium versions."
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:12
msgid "AppArmor for Halium-7.1 ports"
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:14
msgid "Start by downloading the backported `AppArmor patch <https://github.com/ubports/AppArmor-backports-ut>`_ corresponding to your device's kernel version. Your kernel version is specified at the beginning of your kernel defconfig file, i.e. the one you edited in section :ref:`H7_edit-kernel-config` above. (For more information on backporting, see the :ref:`bluetooth <Bluetooth>` section below.)"
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:16
msgid "You now need to delete your entire BUILDDIR/kernel/VENDOR/MODEL/security/apparmor subdirectory and replace it with the one you downloaded. Then rebuild ``halium-boot.img``."
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:18
msgid "If you get errors when building, resolve them one at a time, modifying your source code as needed. Note that you should only modify the code in the AppArmor subdirectory if at all possible. Modifying code elsewhere will more than likely just compound your problems."
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:20
msgid "Seek help as needed from one of the sources mentioned in the subsection on :ref:`getting community help <Getting-community-help>`."
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:22
msgid "Once you have successfully rebuilt ``halium-boot.img``, flash it to your device. If keyboard vibration works, this is a good indication that AppArmor has been successfully applied. Also, check if apps launch normally."
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:25
msgid "AppArmor for Halium-9.0 ports"
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:27
msgid "When doing Halium-9.0 (and later) ports, it is generally sufficient to cherry pick certain commits to the kernel source rather than replacing the whole ``apparmor`` directory in the kernel source tree. Follow the link below which corresponds to your device's kernel version and select the most recent block of commits (i.e. all the commits that were added on the same and most recent date):"
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:29
msgid "`3.18 AppArmor patches <https://github.com/MotoZ-2016/android_kernel_motorola_msm8996/commits/halium-9.0/security/apparmor>`_"
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:30
msgid "`4.4 AppArmor patches <https://github.com/moto-SDM660/android_kernel_motorola_sdm660/commits/halium-9.0/security/apparmor>`_"
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:31
msgid "`4.9 AppArmor patches <https://github.com/erfanoabdi/android_kernel_motorola_sdm632/commits/halium-9.0/security/apparmor>`_"
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:32
msgid "`4.14 AppArmor patches <https://github.com/kdrag0n/proton_zf6/commits/halium/security/apparmor>`_"
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:34
msgid "Make sure your kernel defconfig has the setting::"
msgstr ""

#: ../../porting/configure_test_fix/Apparmor.rst:38
msgid "Now rebuild the boot image following your chosen build method, and flash it onto your device. Check if keyboard vibration works. This is a good indication that AppArmor has been successfully applied. Also, check if apps launch normally."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:4
msgid "Bluetooth"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:6
msgid "Halium-7.1 porting to devices with kernels predating 4.2 will or may require backporting drivers from a newer kernel version, whereas Halium-9.0 based ports can skip this step."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:9
msgid "Bluetooth backporting to older kernel versions"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:11
msgid "When porting to devices running older kernel versions (mainly version 3.x found in Android 7/ Halium-7.1 devices), it is necessary to replace the kernel bluetooth stack with a newer one. This is because the newer bluetooth hardware in today's bluetooth peripheral devices often has trouble talking to the older bluetooth drivers. This can be fixed by bringing in driver code from newer Linux kernel versions. The process is called *backporting*."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:15
msgid "Backporting has been greatly facilitated by the `Linux Backports Project <https://backports.wiki.kernel.org/index.php/Main_Page>`_ which has existed for some time. This project is aimed at mainline Linux kernels and the tools (scripts) therein are not specifically tailored to Ubuntu Touch. They will consequently abort at some point during the process. However, they are the best option available, and can provide significant help all the same. The method below is based on the use of a version of these scripts which has been specially prepared by Canonical."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:19
msgid "Although there are `other kernel versions besides v4.2 available <https://www.kernel.org/>`_, the backports script is specifically tailored to backporting from version 4.2 and thus effectively limits you to this option."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:22
msgid "Bluetooth backporting steps"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:24
msgid "The steps are as follows:"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:26
#: ../../porting/configure_test_fix/Bluetooth.rst:40
msgid "Record bluetooth driver and settings"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:27
#: ../../porting/configure_test_fix/Bluetooth.rst:67
msgid "Download backports script"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:28
msgid "Download 4.2 kernel source"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:29
#: ../../porting/configure_test_fix/Bluetooth.rst:88
msgid "Run backports script and fix errors"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:30
#: ../../porting/configure_test_fix/Bluetooth.rst:97
msgid "Apply security patch"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:31
#: ../../porting/configure_test_fix/Bluetooth.rst:102
msgid "Apply new settings"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:32
#: ../../porting/configure_test_fix/Bluetooth.rst:175
msgid "Build and flash halium-boot.img"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:33
#: ../../porting/configure_test_fix/Bluetooth.rst:219
msgid "Build and flash system.img"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:35
msgid "These steps will bring in bluetooth driver source from the mainline 4.2 kernel and place it in a directory named ``backports`` in your device's kernel source tree. It will also modify Makefiles and Kconfigs as necessary, thereby disabling the original ``drivers/bluetooth`` directory of your kernel source. The mainline kernel may not contain all bluetooth drivers required for the device being ported. For this reason it is important to make sure to first record all necessary drivers, as any ones missing in the mainline kernel will have to be migrated from their original location (``drivers/bluetooth``) into the ``backports/drivers/bluetooth`` directory as described :ref:`later in this section <Missing-drivers>` before rebuilding halium-boot.img."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:42
msgid "By the time you reach this point in the porting process, you will have completed building halium-boot (probably a number of times). Your kernel defconfig will contain bluetooth settings including one that designates the driver used by your device. These must be recorded before proceeding."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:44
msgid "The experienced developer will likely be able to determine the relevant settings manually by searching through the defconfig file. Many of them will appear next to each other in one place in the file. Some may be spread elsewhere making them difficult to locate. When searching manually, help can be found by consulting the `Kconfig` files in relevant subdirectories of your kernel source tree."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:46
msgid "If you do not have extensive experience, use the ``menuconfig`` tool instead, taking care to use it ONLY for reference, *i.e.* without making any changes."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:50
msgid "Modifications done with ``menuconfig`` will not affect your kernel defconfig file, but may still corrupt your build."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:52
msgid "After completing a build of halium-boot.img::"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:57
msgid "(If your device is armhf, use ``ARCH=arm`` instead.)"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:59
msgid "Navigate to the bluetooth drivers submenu and note down all activated settings and what they do. Also note which other settings they depend on (found under Help)."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:62
msgid "Example:"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:64
msgid "For the Samsung Galaxy S7 (herolte) the original defconfig file contains a number of CONFIG_BT settings, none of which actually designate the bluetooth driver used by this device. The setting for the driver itself is CONFIG_BCM4359=y. This was not one of the drivers brought in by the backporting steps below. It therefore had to be :ref:`added afterwards <Missing-drivers>`."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:69
msgid "Clone the backports scripts into a directory outside your halium source tree by issuing this command from your home (~) directory::"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:73
msgid "This downloads the backports scripts prepared by Canonical based on the `Backports Project <https://backports.wiki.kernel.org/index.php/Main_Page>`_ mentioned above, and places them in the directory ``~/backport-scripts``. The scripts are specifically written to backport from kernel version 4.2."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:76
msgid "Download 4.2 kernel sources"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:78
msgid "Create a directory (outside your halium source tree) for the kernel source from which you will pull the newer drivers::"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:82
msgid "Now clone the kernel source for v4.2::"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:90
msgid "Navigate to your backports scripts directory and issue the command below (using Python2 as shown)::"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:94
msgid "It is to be expected that there are errors during this step. You will then have to determine the cause, fix it and retry. The last error message concerns the Makefile and includes info about having generated a file named ``Makefile.rej``, this means you will find information in this file about changes that did not complete successfully, but which you can apply yourself. These need to be completed before proceeding with the build."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:99
msgid "An additional `generic security patch <https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=8a7b081660857a80c3efc463b3da790c4fa0c801>`_ needs to be applied."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:104
msgid "Your kernel config file (defconfig) needs to be modified in order for the backported driver and protocol code to be activated."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:106
msgid "Start by locating all lines beginning with ``CONFIG_BT_`` and move these to the end of the file. Collecting them there makes the subsequent steps somewhat easier by helping to keep track of the changes you make."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:108
msgid "Next, deactivate all that are activated, *i.e.* do not have a leading ``#``, by inserting this leading ``#``. At the same time, for each one, add a corresponding one beginning with ``CONFIG_BACKPORT_BT_``, *e.g.*::"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:112
msgid "becomes::"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:116
msgid "and then insert the corresponding line for backports::"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:120
msgid "Now add these settings::"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:138
msgid "At this point, check for any remaining settings you :ref:`recorded from your original defconfig <BT-driver>`, which were dependent upon ``CONFIG_BT=y`` and have not been replaced by a corresponding ``CONFIG_BACKPORT_BT_XXXX=y`` setting, making sure not to forget your device's bluetooth driver. Such settings will no longer have any effect and must be pulled into the build in the following manner:"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:140
msgid "The corresponding source file(s) will have to be migrated from their original location to the corresponding location under ``backports/drivers/bluetooth/``. The files ``Makefile`` and ``Kconfig`` need to be edited to include this missing setting or else they will not be built. Check the corresponding files in the original location for the necessary settings."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:142
msgid "Once the above is complete, add the following lines and edit as necessary, following the directions below::"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:170
msgid "As an example, the lines above have been edited to conform with backporting from kernel 4.2 to a device with kernel version 3.18. For devices running lower kernel versions enable each line specifying a version above the device's kernel version by removing the leading ``#`` on these lines."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:172
msgid "You are now ready to build."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:177
msgid "Return to the root of your BUILDDIR and build::"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:181
msgid "Build errors may occur and will vary depending on device. Handle them one at a time, :ref:`seeking help <Getting-community-help>` as necessary."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:183
msgid "After building and flashing halium-boot, check the output of ``dmesg`` on the device to see that bluetooth has been enabled::"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:187
msgid "Your output should resemble the following (from the Samsung Galaxy S7)::"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:214
msgid "If you do not get similar output, something has gone wrong. Check that you completed all steps above as described and seek help as needed."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:216
msgid "You have now rebuilt your halium-boot.img to include updated bluetooth drivers and only one final step remains."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:221
msgid "The system image needs to be rebuilt with a configuration script for bluetooth adapted to your device. On the completed build, this file is located at::"
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:225
msgid "`An example script can be found here <https://github.com/Flohack74/android_device_huawei_angler/blob/halium-7.1/ubuntu/bluetooth/bluetooth-touch-android.conf>`_. Make sure to adapt as necessary."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:227
msgid "Place this script in your ``device/[VENDOR]/[DEVICE]/ubuntu`` directory and inject it using the :ref:`overlay file method <Overlay>`."
msgstr ""

#: ../../porting/configure_test_fix/Bluetooth.rst:229
msgid "Rebuild and flash your ``system.img``."
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:4
msgid "Display settings"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:6
msgid "There are two variables that set the content scaling for Lomiri and Ubuntu Touch applications: ``GRID_UNIT_PX`` and ``QTWEBKIT_DPR``."
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:8
msgid "There are also other options available that may be useful for you depending on your device's form factor. These are mentioned below and explained in depth :ref:`in the section on display settings<Display-settings>`."
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:10
msgid "All of these settings are guessed by Unity 8 if none are set. There are many cases, however, where the guess is wrong (for example, very high resolution phone displays will be identified as desktop computers). To manually set a value for these variables, simply edit the file at ``etc/ubuntu-touch-session.d/android.conf`` specifying them. For example, this is the file for the Nexus 7 tablet::"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:18
msgid "The method for deriving values for these variables :ref:`is explained below. <Display-settings>`"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:20
msgid "Once you have adjusted the ``android.conf`` file to the display settings needed for your device, this file should be incorporated into your build. Follow :ref:`the overlay file method <Overlay-steps>` corresponding to your Halium version."
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:23
msgid "This way of configuration is considered legacy and will be replaced by :ref:`DeviceInfo <DeviceInfo>` in the future. For migration purposes please set both configurations (``android.conf`` as well as :ref:`DeviceInfo <DeviceInfo>`)."
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:29
msgid "Determining the correct display settings"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:32
msgid "Display scaling"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:34
msgid "``GRID_UNIT_PX`` (Pixels per Grid Unit or Px/GU) is specific to each device. Its goal is to make the user interface of the system and its applications the same *perceived* size regardless of the device they are displayed on. It is primarily dependent on the pixel density of the device’s screen and the distance to the screen the user is at. The latter value cannot be automatically detected and is based on heuristics. We assume that tablets and laptops are the same distance and that they are held at 1.235 times the distance phones tend to be held at."
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:36
msgid "``QTWEBKIT_DPR`` sets the display scaling for the Oxide web engine, so changes to this value will affect the scale of the browser and webapps."
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:38
msgid "A reference device has been chosen from which we derive the values for all other devices. The reference device is a laptop with a 120ppi screen. However, there is no exact formula since these options are set for *perceived* size rather than *physical* size. Here are some values for other devices so you may derive the correct one for yours:"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:41
msgid "Device"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:41
msgid "Resolution"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:41
msgid "Display Size"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:41
msgid "PPI"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:41
msgid "Px/GU"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:41
msgid "QtWebKit DPR"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:43
msgid "'Normal' density laptop"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:43
#: ../../porting/configure_test_fix/Display.rst:45
msgid "N/A"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:43
msgid "96-150"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:43
msgid "8"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:43
msgid "1.0"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:44
msgid "ASUS Nexus 7"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:44
msgid "1280x800"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:44
msgid "7\""
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:44
msgid "216"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:44
msgid "12"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:44
#: ../../porting/configure_test_fix/Display.rst:46
#: ../../porting/configure_test_fix/Display.rst:47
#: ../../porting/configure_test_fix/Display.rst:48
msgid "2.0"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:45
msgid "'High' density laptop"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:45
msgid "150-250"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:45
msgid "16"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:45
msgid "1.5"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:46
msgid "Samsung Galaxy Nexus"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:46
msgid "1280x720"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:46
msgid "4.65\""
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:46
msgid "316"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:46
#: ../../porting/configure_test_fix/Display.rst:47
msgid "18"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:47
msgid "LG Nexus 4"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:47
msgid "1280x768"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:47
msgid "4.7\""
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:47
msgid "320"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:48
msgid "Samsung Nexus 10"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:48
msgid "2560x1600"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:48
msgid "10.1\""
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:48
msgid "299"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:48
msgid "20"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:49
msgid "Fairphone 2"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:49
#: ../../porting/configure_test_fix/Display.rst:50
msgid "1080x1920"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:49
msgid "5\""
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:49
msgid "440"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:49
#: ../../porting/configure_test_fix/Display.rst:50
msgid "23"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:49
#: ../../porting/configure_test_fix/Display.rst:50
msgid "2.5"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:50
msgid "LG Nexus 5"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:50
msgid "4.95\""
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:50
msgid "445"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:53
msgid "Experiment with a few values to find one that feels good when compared to the Ubuntu Touch experience on other devices. If you are unsure of which is the best, share some pictures (including some object for scale) along with the device specs with us."
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:55
msgid "There are two other settings that may be of interest to you:"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:58
msgid "Form factor"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:60
msgid "``FORM_FACTOR`` specifies the device's form factor. This value is set as the device's Chassis, which you can find by running ``hostnamectl``. The acceptable values are ``handset``, ``tablet``, ``laptop`` and ``desktop``. Apps such as the gallery use this information to change their functionality. For more information on the Chassis, see the freedesktop.org hostnamed specification."
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:63
msgid "Native orientation"
msgstr ""

#: ../../porting/configure_test_fix/Display.rst:65
msgid "``NATIVE_ORIENTATION`` sets the display orientation for the device's built-in screen. This value is used whenever autorotation isn't working correctly or when an app wishes to be locked to the device's native orientation. Acceptable values are ``landscape``, which is normally used for tablets, laptops, and desktops; and ``portrait``, which is usually used for phone handsets."
msgstr ""

#: ../../porting/configure_test_fix/Lomiri.rst:4
msgid "Lomiri - the graphical UI"
msgstr ""

#: ../../porting/configure_test_fix/Lomiri.rst:6
msgid "Now that you have gained access to your newly booted device, there remain a number of things to be configured before Ubuntu Touch will be fully functional on your device. The first is to add udev rules which are required for the graphical UI to be able to launch."
msgstr ""

#: ../../porting/configure_test_fix/Lomiri.rst:9
msgid "What are udev rules?"
msgstr ""

#: ../../porting/configure_test_fix/Lomiri.rst:11
msgid "On your running system there is a continuously running udev daemon which governs how the system handles events on peripheral devices, *e.g.* connecting the device to a PC via USB cable. This daemon needs a set of rules, *the udev rules*, to tell it what to do for each possible event. These rules must observe a specific format and they are stored in a file which needs to be generated for each specific device."
msgstr ""

#: ../../porting/configure_test_fix/Lomiri.rst:14
msgid "Add udev rules"
msgstr ""

#: ../../porting/configure_test_fix/Lomiri.rst:16
msgid "The correct way to do this is by storing these settings in overlay files (:ref:`Overlay`), and not by making the root directory writeable, as described below. However, in order to quickly set up udev rules which are necessary to complete subsequent steps, you can use the method detailed here for first time setup."
msgstr ""

#: ../../porting/configure_test_fix/Lomiri.rst:19
msgid "Make / (root) writable"
msgstr ""

#: ../../porting/configure_test_fix/Lomiri.rst:21
msgid "Before you make any changes to the rootfs (which will be required for the next steps), you'll need to remount your root directory (/) with write permissions. Do this by running the following command::"
msgstr ""

#: ../../porting/configure_test_fix/Lomiri.rst:26
msgid "Create and add udev rules"
msgstr ""

#: ../../porting/configure_test_fix/Lomiri.rst:28
msgid "You must create some udev rules to allow Ubuntu Touch software to access your hardware."
msgstr ""

#: ../../porting/configure_test_fix/Lomiri.rst:30
msgid "If you are building a Halium-7.1 based port, run the following command, replacing [CODENAME] with your device's codename::"
msgstr ""

#: ../../porting/configure_test_fix/Lomiri.rst:35
msgid "For a Halium-9.0 based port you should use the commands below, again replacing [CODENAME] with your device's codename::"
msgstr ""

#: ../../porting/configure_test_fix/Lomiri.rst:42
msgid "If you are building a Halium-9.0 based port for a non-treble device, i.e. a device without a separate vendor partition, the command above will give an error. Simply edit and remove the following string from the command: ``/vendor/ueventd*.rc``."
msgstr ""

#: ../../porting/configure_test_fix/Lomiri.rst:44
msgid "Now, reboot the device. If all has gone well, you will eventually see the Ubuntu Touch spinner followed by Unity 8. Your lock password is the same as you set for SSH."
msgstr ""

#: ../../porting/configure_test_fix/Lomiri.rst:46
msgid "When Unity 8 is first brought up on your device, you will probably notice that everything is very small. The :ref:`Display` section describes how to deal with this."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:4
msgid "Overlay file method"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:7
msgid "Overview"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:9
msgid "The UBports root filesystem image provides a set of default configuration files for a number of features such as display scaling, sound, bluetooth and more. These files may not be tailored to the device-specific features of the porting target and may therefore have to be adjusted. Furthermore, it may be also be necessary to add additional configuration files as well as scripts for specific needs. Overlay files provide a solution for replacing existing or adding new files to the file system."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:11
msgid "The way how overlay files are implemented and their limitations vary across build methods and different versions of Ubuntu Touch. Use of the halium-install script to install a build based on the downloaded GSI and root filesystem image precludes the use of overlay files since it does not provide a mechanism for that."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:13
msgid "In general, there are two methods of implementing overlay files, one is to directly copy them to the destination path potentially overwriting existing files, the other is to place them in a designated base directory from where they are then mounted onto their destination path during the boot process. The former is only possible when doing builds using the GitLab CI scripts. In case of Ubuntu Touch 16.04 it is the only available overlay mechanism. While the ``system.img`` build process allows overwriting files on the built Android system partition it has no means of doing so on the root filesystem. Ubuntu Touch 16.04 does however offer limited support of mount-based overlay files. Starting from Ubuntu Touch 20.04, the implementation of mount-based overlay files has become more powerful in terms of overlaying both files and directories in vendor and Android images regardless of the build method. The use of mount-based overlay files is generally preferable as it allows for delta OTA updates. Both mechanisms will be discussed in detail below before describing how overlay files are included into the build process in full system image builds and builds based on GitLab CI scripts."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:17
msgid "Some ports of Ubuntu Touch 16.04 using the GitLab CI-based build method add custom scripts or configuration files (e.g. in ``/usr/sbin/mount-android.sh``, ``/etc/init/mount-android.conf``, or a file in ``/etc/init/``) in order to overlay files below ``/android/system`` which would otherwise not be possible using this build method. This practice is strongly discouraged for a several reasons:"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:19
msgid "overwriting a system script prevents the port from receiving future updates of that script"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:20
msgid "different ports coming up with custom solutions creates confusion among new porters and contributors"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:22
msgid "Porters which are in need of overlaying files inside a GSI-based ``/android/system.img`` may want to consider using the full ``system.img`` build method instead."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:24
msgid "The implementations and limitations can be summarized as follows:"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:27
msgid "Build method"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:27
#: ../../porting/configure_test_fix/Overlay.rst:42
msgid "Ubuntu Touch 16.04"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:27
msgid "Ubuntu Touch 20.04"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:29
msgid "full ``system.img`` build"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:29
msgid "add/overwrite files below ``/android/system``"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:30
msgid "overlay existing files on the root filesystem"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:31
msgid "no new files on the root filesystem"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:30
msgid "overlay existing files on the root filesystem, android and vendor filesystem"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:31
#: ../../porting/configure_test_fix/Overlay.rst:35
msgid "new files and directories via merged or replaced overlay directories"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:33
msgid "GitLab CI-based build"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:33
msgid "add/overwrite files on the root file system"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:33
msgid "add/overwrite files on the root file system (use overlays instead)"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:34
msgid "overlay mounts for existing files on the root, android and vendor filesystem"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:39
msgid "How mount-based overlay files work"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:44
msgid "Ubuntu Touch 16.04 only offers mount-based overlay files in case of full ``system.img``-based builds with the limitation that the overlayed files must actually exist on the root filesystem partition, adding new files is not possible."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:46
msgid "Overlay files need to be placed on the android system partition below the designated base directory which is mounted at ``/android/system/halium`` on the device. The directory tree with overlay files below that base directory mirrors the structure of the root filesystem, that is the destination path of an overlay file on the root filesystem is derived from its location relative to the base directory. For example, in order to overlay the udev rules file ``/lib/udev/rules.d/70-android.rules`` created in the last step it needs to exist in the directory ``/android/system/halium/lib/udev/rules.d/``. The specifics on how an overlay file can be placed there by the build system will be described below."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:49
msgid "Ubuntu Touch 20.04 and later"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:51
msgid "Ubuntu Touch 20.04 and later provide a much more flexible implementation which is available both to full ``system.img``-based builds as well as GitLab CI script-based builds. It not only allows overlaying individual files but also replacing or merging existing directories without actually modifying the underlying filesystem.  Furthermore, it is not restricted to the Ubuntu Touch root partition but can also overlay files and directories in vendor and Android partitions."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:53
msgid "Depending on the build method the designated base directory is either ``/opt/halium-overlay`` or ``/android/system/halium`` on the device. The directory tree below the base directory mirrors the root filesystem and destination paths are derived based on the relative location of a directory or file to the base directory.  Note that the files or directories under the destination path must neither be writable nor mount points themselves.  The overlay directory tree will be traversed in depth-first order during boot according to the following rules:"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:55
msgid "If a subdirectory contains a special file named ``.halium-override-dir`` that directory will replace the destination directory tree, i.e. the contents of the underlying directory and its descendants will no longer be accessible."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:57
msgid "If a subdirectory contains a special file named ``.halium-overlay-dir`` it will be merged with with the destination directory.  Any file in the underlying directory or descendants thereof remain accessible if no file with the same destination path exists in the overlaying directory tree.  Files and whole directories which only exist in the overlay are made accessible in their respective destination paths.  This is implemented using the overlayfs filesystem (see the `overlayfs documentation <https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html>`_ for the technical details)."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:59
msgid "Files in directories containing none of the above special files are bind-mounted over files with an absolute path derived by stripping the above prefix. Subdirectories will be further traversed and evaluated according to the outlined rules."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:61
msgid "The specifics on how an overlay file or directory can be placed there depends on the used build system and will be described below."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:64
#: ../../porting/configure_test_fix/Overlay.rst:125
#: ../../porting/configure_test_fix/Overlay.rst:156
msgid "Example"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:66
msgid "Contents of ``overlay/system/halium``::"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:83
msgid "Contents of the underlying filesystem image::"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:97
msgid "The resulting combined filesystem the looks as follows::"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:113
msgid "The directory ``/etc/foo`` has been merged, whereas the ``/etc/bar`` directory and the file ``/etc/bazrc`` have been replaced."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:118
msgid "Overlay files in full system.img builds"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:120
msgid "In the case of full ``system.img``-based builds all supported Halium versions allow for copying overlay files to the Android system filesystem image during the build process by adding entries to the ``PRODUCT_COPY_FILES`` macro. Each entry consists of the source and destination path of a file, seperated by a “``:``”. As a matter of convention, all overlay files should be placed in a directory ``ubuntu`` below the root path of the repository. This directory can be referred to as ``$(LOCAL_PATH)/ubuntu``. The destination directory should be specified relative to its default mountpoint ``/android/system`` referred to as ``$(TARGET_COPY_OUT_SYSTEM)``."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:122
msgid "It is thus only possible to add or overwrite files below ``/android/system``. In order to make use of mount-based overlay files they should be placed below the designated base directory ``/android/system/halium`` as described above. Due to the limitations in Ubuntu 16.04 it is only possible to add new files via overlay or override directories available in Ubuntu 20.04 or later."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:127
msgid "Typically at least the file ``/lib/udev/rules.d/70-android.rules`` created when bringing up Lomiri (see :ref:`Lomiri`) and the file ``/etc/ubuntu-touch-session.d/android.conf`` for configuring display scaling need to be added via overlay files. The bind mount mechanism of both Ubuntu Touch 16.04 and 20.04 requires that the files are placed below the designated base directory ``/android/system/halium``, that is at ``/android/system/halium/lib/udev/rules.d/70-android.rules`` and ``/android/system/halium/etc/ubuntu-touch-session.d/android.conf``"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:129
msgid "Both ``70-android.rules`` and ``android.conf`` should be placed in the subdirectory ``ubuntu`` of the repository and the following lines need to be added to ``device.mk`` in order to copy them onto the generated image::"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:140
msgid "Rebuilding system.img"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:142
msgid "After any changes the ``system.img`` needs to be rebuilt using ``mka clean`` and ``mka systemimage``. When repeatedly rebuilding the system image after small changes, it is possible to do incremental builds without issuing a ``mka clean`` first. However, changes to PRODUCT_PROPERTY_OVERRIDES might not get detected by the build system. In that case the file ``build.prop`` in the directory ``BUILDDIR/out/target/product/CODENAME/system`` should be removed manually before rebuilding."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:144
msgid "After a successful build, the resulting ``system.img`` must reflashed together with the UBports root filesystem. On boot files and – in case of Ubuntu Touch 20.04 or later – marked directories in ``/android/system/halium`` will be mounted onto their final locations which are derived from their path relative to the designated base directory."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:147
msgid "Overlay files in Gitlab CI script-based builds"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:149
msgid "When using Gitlab CI script-based builds (see :ref:`Gitlab-CI`) overlay files and directories have to be placed in in the repository below ``overlay/system`` in a directory tree mirroring the structure of the root filesystem."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:151
msgid "By default, the build system will cause the file to be overwriten directly in the filesystem. This allows arbitrary files to be added to the rootfs, but can cause problem when the overlaid file gets updated in the base system as part of the delta upgrade. Ubuntu Touch 16.04 supports only this mode."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:153
msgid "While Ubuntu Touch 16.04 only allows overlaying files by overwriting them, in case of Ubuntu Touch 20.04 or later versions the mount-based overlay files should be used instead. This can be done by specifying ``deviceinfo_use_overlaystore=\"true\"`` in the port's ``deviceinfo``. If the port is not using the shared building script, it'll have to transition to the shared build script too (see :ref:`UpdatePortsFor2004`). When the option is being set, the build script ensures that the file ends up inside ``/opt/halium-overlay`` in the system, and gets mounted in the same way as ``system.img`` builds. Thus, the same config and limitations apply."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:158
msgid "Following the above example, overlaying files ``/lib/udev/rules.d/70-android.rules`` and ``/etc/ubuntu-touch-session.d/android.conf`` requires placing the file at ``overlay/system/lib/udev/rules.d/70-android.rules`` and ``overlay/system/etc/ubuntu-touch-session.d/android.conf`` in the repository."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:160
msgid "For ports with ``deviceinfo_use_overlaystore=\"true\"`` running Ubuntu Touch 20.04, the files will end up in ``/opt/halium-overlay/``, and will be bind-mounted into their respective places."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:162
msgid "In case of Ubuntu Touch 16.04 or port without ``deviceinfo_use_overlaystore=\"true\"``, the files on the root filesystem will be overwritten due to the lack of mount-based overlay files."
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:165
msgid "Building on GitLab CI"
msgstr ""

#: ../../porting/configure_test_fix/Overlay.rst:167
msgid "After adding or modifying overlay files the Gitlab CI scripts need to be run according to `the instructions included <https://gitlab.com/ubports/community-ports/android9/xiaomi-redmi-note-7-pro/xiaomi-violet/-/blob/master/README.md>`_. On boot files and – in case of Ubuntu Touch 20.04 or later – marked directories in ``/opt/halium-overlay`` will be mounted onto their final locations which are derived from their path relative to the designated base directory."
msgstr ""

#: ../../porting/configure_test_fix/Sound.rst:2
msgid "Sound"
msgstr ""

#: ../../porting/configure_test_fix/Sound.rst:4
msgid "Ubuntu Touch uses Pulseaudio as sound server. Documentation can be found at `freedesktop.org <https://www.freedesktop.org/wiki/Software/PulseAudio/Documentation/>`_ and in the `Ubuntu manpages <https://manpages.ubuntu.com/manpages/focal/man1/pulseaudio.1.html>`_"
msgstr ""

#: ../../porting/configure_test_fix/Sound.rst:6
msgid "The default configuration file used on Ubuntu Touch is ``touch.pa``. This file is located in the ``/etc/pulse`` directory on your device and it will need adjustment in order for sound to function properly. Extract the file and copy it to the ``ubuntu`` directory you created in your device repo (see :ref:`Overlay`)."
msgstr ""

#: ../../porting/configure_test_fix/Sound.rst:8
msgid "Locate the line::"
msgstr ""

#: ../../porting/configure_test_fix/Sound.rst:12
msgid "and replace it with this::"
msgstr ""

#: ../../porting/configure_test_fix/Sound.rst:16
msgid "At the end of the file, append this::"
msgstr ""

#: ../../porting/configure_test_fix/Sound.rst:23
msgid "Your modified ``touch.pa`` file now needs to be included in your build. Follow :ref:`the overlay file method <Overlay-steps>` corresponding to your Halium version."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:4
msgid "Configuring usb-moded"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:7
msgid "Information on this page is applicable for ports supporting Ubuntu Touch 20.04. To make your port support Ubuntu Touch 20.04, see :ref:`UpdatePortsFor2004`."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:9
msgid "usb-moded is a new daemon in Ubuntu Touch 20.04 which handles transitions between USB modes e.g. MTP and developer mode. It replaces a number of ad-hoc Upstart jobs on 16.04, and ``setupusb`` script used by recent ports."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:11
msgid "The system can detects most of the important settings. But for usb-moded to work best, we encouraged porters to give some configurations to ensure best experience for porters."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:14
msgid "History of the USB mode handling"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:16
msgid "In Ubuntu Touch 16.04, we used Android properties to store and set the phone's USB configuration. This worked well in the past, but today it doesn't work anymore:"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:18
msgid "From Halium 7.1, the component in the Android side which sends signal to Upstart to drive state transition is not going in. Besides, the signal concept doesn't seem to exist in Systemd."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:19
msgid "From Android 8, USB mode configuration code moved into a vendor-controlled HAL process which talks over HIDL."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:21
msgid "This has led to porters resorting to an ad-hoc script like ``setupusb`` which runs at boot to configure the USB mode once. And when a basic things like this gets pushed to porters, inevitably it leads to fragmentation."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:23
msgid "On Ubuntu Touch 20.04, we transition to usb-moded which is a daemon originating from SailfishOS. The daemon doesn't rely on Android properties, but requires configuration. We've created a \"configurator\" which auto-detect many of those settings, but it cannot detect everything. So, some configuration from the porters is still required."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:26
msgid "The basic configurations"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:28
msgid "The main configuration is at ``/etc/default/usb-moded.d/device-specific-config.conf`` which porters can use the overlay system to place the file. The file is in a simple ``<key>=<value>`` format. An example of it is as below:"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:39
msgid "The following can be configure:"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:42
msgid "USB vendor & product IDs"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:44
msgid "The following configurations are highly-recommended to be set. Without it, the system will fallback to the test code from `pid.codes project <https://pid.codes/pids/>`_."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:46
msgid "IDVENDOR"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:47
msgid "IDPRODUCT_MTP"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:48
msgid "IDPRODUCT_MTP_ADB"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:49
msgid "IDPRODUCT_RNDIS"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:50
msgid "IDPRODUCT_RNDIS_ADB"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:52
msgid "It accepts the IDs in hexadecimal without ``0x`` prefix. The IDs could be found in:"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:54
msgid "Your device's ``init.<device>.rc`` or ``init.<chipset>.rc``."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:55
msgid "Your device's USB HAL source code, if it happens to ship one."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:56
msgid "Your device's ``setupusb`` script, if available."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:58
msgid "Failing that, you might have to probe how your device shows up when booted on Android."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:61
msgid "We're aware that some device use different vendor IDs for different modes. If your device are one of those, please upvote `this issue on GitLab <https://gitlab.com/ubports/development/core/packaging/usb-moded/-/issues/5>`_."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:64
msgid "Devices' pretty name"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:66
msgid "This is the name that will show up when plugged into a computer. Most of the time, we can detect this from Android properties, but if the detection is not correct or you would like the device to display differently, it can be configured here."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:68
msgid "MANUFACTURER"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:69
msgid "PRODUCT"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:72
msgid "usb-moded's arguments"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:74
msgid "This config controls the launching flag of the usb-moded daemon itself. Most of the time, usb-moded should work without any flag. However, the rootfs ships a default with ``-r`` which enables the rescue mode upon boot (see below). The behavior of the rescue mode can be confusing for end users, so it's recommended that porters config this value to the blank value to disable the rescue mode."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:76
msgid "USB_MODED_ARGS"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:79
msgid "About usb-moded's rescue mode"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:81
msgid "usb-moded's rescue mode is similar to hybris-usb's usb-tethering mode. It enables the phone's USB to function as a network interface, and starts a DHCP server. The phone will be available at 10.15.19.82, and an emergency SSH server will be available on port 8022. This is intended for porters to debug issues during the development, and thus it will stay in that mode until the cable is re-plugged."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:83
msgid "This behavior is helpful for the porters. However, this can be confusing to end-users when the port is shipped. So I recommended disabling this mode before making the port available to users by overriding ``USB_MODED_ARGS`` as discussed above."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:85
msgid "Another rescue feature available is the ability to force usb-moded to go to \"rescue mode\" or to enable ADB on every boot. This can be done by placing an empty file at ``/userdata/.force-ssh`` or ``/userdata/.force-adb`` (which translate to ``/data/.force-ssh`` or ``/data/.force-adb`` in the recovery), and the system will make sure the correct mode is enabled."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:88
msgid "If using ADB, you may also have to disable ADB authorization prompt. See :ref:`AdbdAuthz`."
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:91
msgid "Configuring usb-moded directly"
msgstr ""

#: ../../porting/configure_test_fix/USBModed.rst:93
msgid "Besides tweaking options for the configurator script, porters can also set usb-moded options directly via ``/etc/usb-moded/90-device-specific-config.ini``. However, this is intended as an escape hatch in case the automatic detection fails, and if you found yourself need to use this file, consider filing issue over usb-moded's packaging repository. See `usb-moded's docs <https://github.com/sailfishos/usb-moded/blob/master/docs/usb_moded-doc.txt>` for the syntax."
msgstr ""

#: ../../porting/configure_test_fix/Wifi.rst:2
msgid "Wifi"
msgstr ""

#: ../../porting/configure_test_fix/Wifi.rst:4
msgid "For the time being, refer to `the Halium porting guide. <https://docs.halium.org/en/latest/porting/debug-build/wifi.html>`_"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:4
msgid "Ayatana-indicator-power"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:6
msgid "All deviceinfo keys used by ayatana-indicator-power are given below::"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:13
#: ../../porting/configure_test_fix/device_info/HfdService.rst:12
#: ../../porting/configure_test_fix/device_info/Repowerd.rst:15
msgid "Device quirks"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:16
#: ../../porting/configure_test_fix/device_info/HfdService.rst:15
#: ../../porting/configure_test_fix/device_info/Mir.rst:20
#: ../../porting/configure_test_fix/device_info/Repowerd.rst:18
#: ../../porting/configure_test_fix/device_info/index.rst:41
msgid "Key"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:16
#: ../../porting/configure_test_fix/device_info/HfdService.rst:15
#: ../../porting/configure_test_fix/device_info/Mir.rst:20
#: ../../porting/configure_test_fix/device_info/Repowerd.rst:18
#: ../../porting/configure_test_fix/device_info/index.rst:41
msgid "Description"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:16
#: ../../porting/configure_test_fix/device_info/HfdService.rst:15
#: ../../porting/configure_test_fix/device_info/Mir.rst:20
#: ../../porting/configure_test_fix/device_info/Repowerd.rst:18
#: ../../porting/configure_test_fix/device_info/index.rst:41
msgid "Value(s)"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:18
msgid "FlashlightSysfsPath"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:18
msgid "Specifies the path to flashlight node for Flashlight toggle in indicator."
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:18
msgid "Path to flashlight node in /sys."
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:19
msgid "FlashlightSwitchPath"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:19
msgid "Specifies the path to the flashlight switch node needed for the kernel driver to actually turn on flashlight."
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:19
msgid "Path to flashlight switch node in /sys."
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:23
#: ../../porting/configure_test_fix/device_info/HfdService.rst:21
#: ../../porting/configure_test_fix/device_info/Mir.rst:63
#: ../../porting/configure_test_fix/device_info/Repowerd.rst:25
msgid "Examples"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:25
#: ../../porting/configure_test_fix/device_info/HfdService.rst:23
#: ../../porting/configure_test_fix/device_info/Mir.rst:65
#: ../../porting/configure_test_fix/device_info/Repowerd.rst:27
msgid "Device ``sample`` using:"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:27
msgid "Change flashlight path to \"/sys/class/leds/led:torch_0/brightness\" to resolve the issue where ayatana-indicator-power will choose the wrong node."
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:28
msgid "Change flashlight switch path so flashlight will actually turn on."
msgstr ""

#: ../../porting/configure_test_fix/device_info/Ayatana-indicator-power.rst:30
#: ../../porting/configure_test_fix/device_info/HfdService.rst:27
#: ../../porting/configure_test_fix/device_info/Mir.rst:72
#: ../../porting/configure_test_fix/device_info/Repowerd.rst:33
msgid "Config file::"
msgstr ""

#: ../../porting/configure_test_fix/device_info/HfdService.rst:4
msgid "hfd-service"
msgstr ""

#: ../../porting/configure_test_fix/device_info/HfdService.rst:6
msgid "Overview of all hfd-service keys::"
msgstr ""

#: ../../porting/configure_test_fix/device_info/HfdService.rst:17
msgid "VibrateDurationExtraMs"
msgstr ""

#: ../../porting/configure_test_fix/device_info/HfdService.rst:17
msgid "Milliseconds to extend all vibration calls by"
msgstr ""

#: ../../porting/configure_test_fix/device_info/HfdService.rst:17
msgid "Any integer number"
msgstr ""

#: ../../porting/configure_test_fix/device_info/HfdService.rst:25
msgid "Extend vibrations by 50 milliseconds to feel the on-screen keyboard haptics on devices with simpler on/off vibration motors"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:4
msgid "Mir"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:6
msgid "Overview of all Mir keys::"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:17
msgid "mir-platform-android"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:20
msgid "Default value"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:22
#: ../../porting/configure_test_fix/device_info/Mir.rst:31
msgid "MirAndroidPlatformClientEglFlush"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:22
#: ../../porting/configure_test_fix/device_info/Mir.rst:23
#: ../../porting/configure_test_fix/device_info/Mir.rst:24
#: ../../porting/configure_test_fix/device_info/Mir.rst:25
#: ../../porting/configure_test_fix/device_info/Mir.rst:26
#: ../../porting/configure_test_fix/device_info/Mir.rst:27
msgid "See below"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:22
#: ../../porting/configure_test_fix/device_info/Mir.rst:23
msgid "Comma-separated list (or special value \"all\")"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:22
#: ../../porting/configure_test_fix/device_info/Mir.rst:23
msgid "Empty"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:23
#: ../../porting/configure_test_fix/device_info/Mir.rst:36
msgid "MirAndroidPlatformClientFenceSync"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:24
#: ../../porting/configure_test_fix/device_info/Mir.rst:41
msgid "MirAndroidPlatformServerBackpressure"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:24
#: ../../porting/configure_test_fix/device_info/Mir.rst:25
#: ../../porting/configure_test_fix/device_info/Mir.rst:26
#: ../../porting/configure_test_fix/device_info/Mir.rst:27
msgid "Boolean"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:24
#: ../../porting/configure_test_fix/device_info/Mir.rst:25
#: ../../porting/configure_test_fix/device_info/Mir.rst:27
msgid "False"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:25
#: ../../porting/configure_test_fix/device_info/Mir.rst:46
msgid "MirAndroidPlatformServerClearFbFence"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:26
#: ../../porting/configure_test_fix/device_info/Mir.rst:51
msgid "MirAndroidPlatformServerEglSync"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:26
msgid "Launcher argument (``default``)"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:27
#: ../../porting/configure_test_fix/device_info/Mir.rst:58
msgid "MirAndroidPlatformServerPartialUpdates"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:33
msgid "Force GL command buffer flush on eglSwapBuffers, in case the driver doesn't follow the spec."
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:38
msgid "Classic fence-only synchronization without GL command buffer flushing."
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:43
msgid "Allows redrawing to be skipped or not after a missed frame, similarly to SurfaceFlinger."
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:48
msgid "Framebuffer changes only continue after the fence has been successfully waited on."
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:53
msgid "Allow or avoid synchronization using EGL fencing primitives when drawing the screen."
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:55
msgid "Overrules existing launcher argument."
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:60
msgid "Allow partial redraws to HWC-assigned server-side buffers."
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:67
msgid "Enabling egl flushing for every client except for ``lomiri`` and ``unity8``"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:68
msgid "Note that you can use ``!`` to invert conditions and turn the `allow` into a `deny` list."
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:69
msgid "Disabling egl sync for the server"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Mir.rst:70
msgid "Enabling partial updates for the server"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Repowerd.rst:4
msgid "Repowerd"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Repowerd.rst:6
msgid "Overview of all repowerd keys::"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Repowerd.rst:20
msgid "BacklightSysfsPath"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Repowerd.rst:20
msgid "File path to backlight device"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Repowerd.rst:20
msgid "File path"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Repowerd.rst:21
msgid "DoubleTapToWake"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Repowerd.rst:21
msgid "Configuration for toggling DT2W"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Repowerd.rst:21
msgid "List of formatted strings: ``<path>|<enable>|<disable>``"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Repowerd.rst:29
msgid "Custom backlight sysfs path to disable autodetection of the path controlling the backlight"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Repowerd.rst:30
msgid "Double Tap to Wake (DT2W) configuration to allow double tapping to wake the device, specifing two potential paths"
msgstr ""

#: ../../porting/configure_test_fix/device_info/Repowerd.rst:31
msgid "It is allowed to specify multiple entries, invalid or non-existant paths will be removed"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:4
msgid "DeviceInfo"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:6
msgid "DeviceInfo allows to set device specific configuration, which can be accessed in an uniform way using `libdeviceinfo <https://gitlab.com/ubports/development/core/deviceinfo>`_."
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:9
msgid "Device specific overrides"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:11
msgid "Configuration files per device are located at ``/etc/deviceinfo/devices/[device].yaml``. It will try to autodetect the correct configuration to load based on model of the device, using android props for halium/android devices and dtb for native linux devices."
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:16
msgid "This file needs to be all lowercase, as any autodetected device name will be converted to lowercase."
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:18
msgid "For example, the file for the Nexus 7 tablet (flo) would be located at ``/etc/deviceinfo/devices/flo.yaml`` and needs to start with the device's name::"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:28
msgid "In case you can not add a new file to the rootfs, you can bind-mount ``/etc/deviceinfo/devices/halium.yaml``. For a reference, see the `configuration bringup for bonito/sargo <https://github.com/fredldotme/android_device_google_bonito/commit/d0ca48aadcde0b74840c3394ac86042033d7f846>`_."
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:31
msgid "If no device specific configuration exists or a key is not specified for the device config, DeviceInfo will fallback to ``/etc/deviceinfo/default.yaml``. Keep your configuration simple and try to not duplicate any entries, which are already defined in ``default.yaml``."
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:34
msgid "Any key can be added without needing to modify deviceinfo to use it. This allows for a lot of flexibility, however keys should be properly documented in order to not duplicate keys."
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:38
msgid "Built-in config keys"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:43
msgid "Name"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:43
msgid "Device name / codename"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:43
#: ../../porting/configure_test_fix/device_info/index.rst:44
msgid "Any string"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:44
msgid "PrettyName"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:44
msgid "Pretty name of the device"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:45
msgid "DeviceType"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:45
msgid "Sets device type"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:45
msgid "desktop, tablet, phone"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:46
msgid "GridUnit"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:46
msgid "Sets scale units"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:46
msgid "Any integer"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:47
msgid "SupportedOrientations"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:47
msgid "Orientations supported by the device"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:47
#: ../../porting/configure_test_fix/device_info/index.rst:48
#: ../../porting/configure_test_fix/device_info/index.rst:49
#: ../../porting/configure_test_fix/device_info/index.rst:50
#: ../../porting/configure_test_fix/device_info/index.rst:51
#: ../../porting/configure_test_fix/device_info/index.rst:52
msgid "Portrait, InvertedPortrait, Landscape, InvertedLandscape"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:48
msgid "PrimaryOrientation"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:48
msgid "Primary orientation of the device"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:49
msgid "PortraitOrientation"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:49
msgid "Orientation of the device when in portrait mode"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:50
msgid "InvertedPortraitOrientation"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:50
msgid "Orientation of the device when in inverted portrait mode"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:51
msgid "LandscapeOrientation"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:51
msgid "Orientation of the device when in landscape mode"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:52
msgid "InvertedLandscapeOrientation"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:52
msgid "Orientation of the device when in inverted landscape mode"
msgstr ""

#: ../../porting/configure_test_fix/device_info/index.rst:55
msgid "Other keys are documented in the component specific subpages."
msgstr ""

#: ../../porting/configure_test_fix/index.rst:2
msgid "Configuring, testing and fixing"
msgstr ""

#: ../../porting/configure_test_fix/index.rst:4
msgid "Now that you have successfully booted your build, you are ready to bring up the graphical UI, merge AppArmor into your port and see to any remaining functionality that needs configuring. This section explains how to perform these tasks."
msgstr ""

#: ../../porting/configure_test_fix/index.rst:6
msgid "If you are doing a GSI port, much, if not all device features, should already work 'out of the box' once you have brought up Lomiri and added AppArmor. For this reason, Halium-9/GSI porting as well as porting based on standalone kernel builds should normally require only udev rules, AppArmor patches and only limited, if any, configuring using the overlay file method. If, despite performing these tasks, your GSI-based build still does not function properly, you may have to resort to building a device-specific ``system.img`` in order to reach your goal."
msgstr ""

#: ../../porting/configure_test_fix/index.rst:8
msgid "On the other hand, Halium 7.1 porting and Halium-9.0 porting (when building the full device-specific ``system.img``) will require the most work."
msgstr ""

#: ../../porting/configure_test_fix/index.rst:10
msgid "Start by bringing up Lomiri, adjusting the display as required, and adding AppArmor. The remaining steps can be performed in arbitrary order and some may not apply to your particular port."
msgstr ""

#: ../../porting/configure_test_fix/index.rst:12
msgid "As you go along, it can be helpful to have a list of device functions to go by when checking what works and what needs debugging and fixing. This list, along with instructions on how to add your device to the list of devices that can run Ubuntu Touch, can be found in `the informative README.md file linked here. <https://gitlab.com/ubports/infrastructure/devices.ubuntu-touch.io/-/blob/main/README.md>`_"
msgstr ""

#: ../../porting/finalize/UBports_installer.rst:4
msgid "Configuring the UBports installer"
msgstr ""

#: ../../porting/finalize/UBports_installer.rst:6
msgid "For the time being, Halium-7.1 porters should refer to the UBports porting notes on `the UBPorts installer and System image <https://github.com/ubports/porting-notes/wiki/HowTo:-UBports-Installer-&-System-Image-(Halium-7.1)>`_."
msgstr ""

#: ../../porting/finalize/UBports_installer.rst:8
#: ../../porting/finalize/UBports_recovery.rst:8
msgid "For Halium-9.0, exact steps are not available at this time. Please :ref:`get in touch with the community for help. <Getting-community-help>`"
msgstr ""

#: ../../porting/finalize/UBports_recovery.rst:4
msgid "Building UBports recovery"
msgstr ""

#: ../../porting/finalize/UBports_recovery.rst:6
msgid "For the time being, Halium 7.1 porters should refer to the UBports porting notes on `the UBPorts installer and System image <https://github.com/ubports/porting-notes/wiki/HowTo:-UBports-Installer-&-System-Image-(Halium-7.1)>`_."
msgstr ""

#: ../../porting/finalize/index.rst:4
msgid "Finalizing the port"
msgstr ""

#: ../../porting/finalize/index.rst:6
msgid "Once most frequently used features are working on your port you can start thinking about finalizing it, i.e. building recovery and preparing the installer so that it is easier for people to install and test it. This can give valuable feedback that will potentially help you to find and diagnose remaining issues faster than you could have done on your own."
msgstr ""

#: ../../porting/finalize/index.rst:8
msgid "Previously, your port has had the rootfs and system image coexisting on the userdata partition. These need to be moved to the system partition in order to ensure a maximum of available space for user data. This is done by modifying the code, building ``recovery.img`` and subsequently rebuilding the boot image."
msgstr ""

#: ../../porting/finalize/index.rst:10
msgid "With the necessary components prepared, these should first be installed in their correct places manually for testing purposes. Once it has been confirmed that the port boots and works as it should, the final step is to prepare and test an installer config file that will permit the automation of the whole process."
msgstr ""

#: ../../porting/introduction/Intro.rst:2
msgid "Introduction to porting"
msgstr ""

#: ../../porting/introduction/Intro.rst:4
msgid "This first section will introduce you to the specifics of porting Ubuntu Touch to an Android device. Note that it is written with the general public in mind, not primarily the experienced porting developer. In subsequent sections we have made an effort to differentiate by keeping the main text more concise in order to meet the needs of the more experienced reader, while providing links to supplementary reading for the less experienced."
msgstr ""

#: ../../porting/introduction/Intro.rst:6
msgid "The guide as a whole is written as a sequence of steps describing how an ideal port might proceed. However, porting is unpredictable and messy. Every device is different and in reality you will likely iterate and revisit some steps, skip over other steps and uncover new and undocumented challenges."
msgstr ""

#: ../../porting/introduction/Intro.rst:11
msgid "What is Ubuntu Touch?"
msgstr ""

#: ../../porting/introduction/Intro.rst:13
msgid "Ubuntu Touch is an open source operating system for mobile devices. It can be ported to devices that originally shipped with Android OS. Alas, the majority of these devices are dependent to some degree on proprietary software."
msgstr ""

#: ../../porting/introduction/Intro.rst:17
msgid "To be specific, device vendors tend to keep the code that speaks directly to the device hardware (the low level device drivers) proprietary. These components are commonly called the `vendor 'blobs' (Binary Large OBjects) <https://en.wikipedia.org/wiki/Proprietary_device_driver>`_. The vendor blobs need to be incorporated into an Ubuntu Touch port. Note that these components are specific not only to each device, but also to each Android version. It is therefore necessary to secure the correct version of these components when building a port."
msgstr ""

#: ../../porting/introduction/Intro.rst:19
msgid "This is why Ubuntu Touch cannot be built completely from source code for most commercial devices. Instead, porting the system to these devices involves integrating the previously mentioned vendor blobs into the rest of the system, which can be built from source."
msgstr ""

#: ../../porting/introduction/Intro.rst:21
msgid "The next component of Ubuntu Touch is a pre-compiled root filesystem which needs to be installed on the device. This component does not communicate directly with the device hardware. Instead, this communication is mediated by a Hardware Abstraction Layer (HAL) which needs to be built for each specific device, because each device has its specific hardware architecture. This component is called Halium  and is available in different versions (5.1 which is largely obsolete, 7.1, 9, 10 and 11 as of writing) corresponding to different Android versions."
msgstr ""

#: ../../porting/introduction/Intro.rst:23
msgid "The `Halium project <https://halium.org/>`_ enables Linux systems to run on Android hardware. It is a joint effort by multiple mobile operating systems, notably Lune OS and UBports."
msgstr ""

#: ../../porting/introduction/Intro.rst:25
msgid "UBports porting builds on top of Halium porting. Consequently, you will be using both the Halium porting guide and the UBports porting guide. At times it may also be helpful to test with one of the other operating systems to debug a problem from different angles."
msgstr ""

#: ../../porting/introduction/Intro.rst:27
msgid "Halium is an indispensible part of an Ubuntu Touch port and is available in the form of open source software. Developing a new version of Halium is a very considerable task which is why only a few versions of Halium are available. Each port of Ubuntu Touch has to be based on one of the available Halium versions and vendor blobs from the corresponding Android version. See the first two columns of the table below for details."
msgstr ""

#: ../../porting/introduction/Intro.rst:29
msgid "Thus an Ubuntu Touch port is composed of the these components:"
msgstr ""

#: ../../porting/introduction/Intro.rst:30
msgid "The Ubuntu Touch (UT) root filesystem (rootfs)"
msgstr ""

#: ../../porting/introduction/Intro.rst:31
msgid "`Halium <https://halium.org/>`_ (contained in the boot and system images)"
msgstr ""

#: ../../porting/introduction/Intro.rst:32
msgid "The vendor blobs"
msgstr ""

#: ../../porting/introduction/Intro.rst:34
msgid "You, the porter, need to build Halium (in part or in whole, depending on :ref:`porting method <Porting-methods>`) and install this together with the Ubuntu Touch rootfs in order to create a functioning Ubuntu Touch port."
msgstr ""

#: ../../porting/introduction/Intro.rst:39
msgid "Android and Halium versions"
msgstr ""

#: ../../porting/introduction/Intro.rst:41
msgid "Halium is built using source code for a modified version of the Android operating system called LineageOS (see `the LineageOS website <https://lineageos.org/>`_ and `wiki <https://wiki.lineageos.org/>`_). The required source code is available online and needs to be downloaded and configured to build the correct Halium version for each individual device port. The table below shows which versions are required for the different Halium versions."
msgstr ""

#: ../../porting/introduction/Intro.rst:44
msgid "Android version"
msgstr ""

#: ../../porting/introduction/Intro.rst:44
msgid "Halium version"
msgstr ""

#: ../../porting/introduction/Intro.rst:44
msgid "Lineage OS (LOS)"
msgstr ""

#: ../../porting/introduction/Intro.rst:46
msgid "7.1"
msgstr ""

#: ../../porting/introduction/Intro.rst:46
msgid "14.1"
msgstr ""

#: ../../porting/introduction/Intro.rst:47
msgid "9.0"
msgstr ""

#: ../../porting/introduction/Intro.rst:47
msgid "16.0"
msgstr ""

#: ../../porting/introduction/Intro.rst:48
msgid "10.0"
msgstr ""

#: ../../porting/introduction/Intro.rst:48
msgid "17.1"
msgstr ""

#: ../../porting/introduction/Intro.rst:49
msgid "11.0"
msgstr ""

#: ../../porting/introduction/Intro.rst:49
msgid "18.1"
msgstr ""

#: ../../porting/introduction/Intro.rst:55
msgid "Generic System Image"
msgstr ""

#: ../../porting/introduction/Intro.rst:57
msgid "Starting with Android version 9.0, a significant change of architecture was introduced. The device-specific vendor blobs now reside on a separate partition instead of sharing a partition with the rest of the system image. This separation of device-specific code from generic code made possible what is known as the **Generic System Image (GSI)**."
msgstr ""

#: ../../porting/introduction/Intro.rst:60
msgid "A GSI is a system image that is built to be able to function with a wide range of devices. Android devices, as of version 9.0, use a GSI. For more information, see the `Android Developer pages <https://developer.android.com/topic/generic-system-image/>`_"
msgstr ""

#: ../../porting/introduction/Intro.rst:62
msgid "The development of the Android GSI architecture also cleared the way for the now available generic Halium 9.0 arm64 system image (hereafter referred to as *the Halium GSI*, or simply *the GSI*) which is used for Ubuntu Touch. This, however, is somewhat different from the Android GSI. For a more detailed explanation of the Halium GSI, please refer to `the wiki page on Gitlab CI builds of the generic Halium system image <https://github.com/ubports/porting-notes/wiki/GitLab-CI-builds-for-devices-based-on-halium_arm64-(Halium-9)>`_."
msgstr ""

#: ../../porting/introduction/Intro.rst:65
msgid "What does this mean for the porting process?"
msgstr ""

#: ../../porting/introduction/Intro.rst:67
msgid "Since the GSI is a prebuilt, device-independent component, it effectively simplifies the task of building a viable port by removing much of the meticulous and time consuming task of getting the hardware-specific vendor blobs compiled into the system image and configured to function properly."
msgstr ""

#: ../../porting/introduction/Intro.rst:72
msgid "Porting methods"
msgstr ""

#: ../../porting/introduction/Intro.rst:74
msgid "This guide documents three different porting methods, which we call: **Full system image method**, **Halium-boot method**, and **Standalone kernel method**. When porting based on Halium 7.1 the Full system image method is the only available method to follow. For Halium 9.0 all three methods are possible."
msgstr ""

#: ../../porting/introduction/Intro.rst:78
msgid "Full system image method"
msgstr ""

#: ../../porting/introduction/Intro.rst:80
msgid "This porting method requires building both the boot image (halium-boot.img) and the full device specific system image (system.img) from source and installing these together with the UBports root file system (rootfs). For Halium 7.1 ports this is the only possible method (Consequently, this method is sometimes referred to as *the Halium 7.1 method*). For Halium 9.0 it is also possible to use this method, however for Halium 9.0 the other two methods below are probably easier."
msgstr ""

#: ../../porting/introduction/Intro.rst:84
msgid "Halium-boot method"
msgstr ""

#: ../../porting/introduction/Intro.rst:86
msgid "For this porting method it is sufficent to build the halium-boot.img and install this together with the Halium GSI and the UBports rootfs. This method can be used for Halium 9.0 ports."
msgstr ""

#: ../../porting/introduction/Intro.rst:91
msgid "This porting method only requires building the kernel and installing this together with the Halium ramdisk, the Halium GSI and the UBports rootfs. This method can be used for Halium 9.0 ports."
msgstr ""

#: ../../porting/introduction/Intro.rst:93
msgid "All methods share some common steps. However, there are also significant differences that must not be missed. Therefore, the methods will be treated separately in the subsequent sections where needed."
msgstr ""

#: ../../porting/introduction/Intro.rst:95
msgid "The remainder of this section gives some words of advice to new porters. If you already have porting experience or ROM building experience, you can likely skip straight to :ref:`Preparations <Preparations>`."
msgstr ""

#: ../../porting/introduction/Intro.rst:100
msgid "The challenges of the porting process"
msgstr ""

#: ../../porting/introduction/Intro.rst:102
msgid "Building the necessary components and getting them to work together properly always involves an amount of code modifications, configuring and testing, but considerably moreso when doing full system image builds, compared to builds using the GSI (see :ref:`porting methods <Porting-methods>`)."
msgstr ""

#: ../../porting/introduction/Intro.rst:104
msgid "Luckily, there is a community of porters out there who are eager to see Ubuntu Touch ported to new devices. When you run into trouble, you should search the sources below (:ref:`Getting-community-help`) to see if others before you have solved the issue. There are online Telegram chat groups you can join to ask for help, but please bear in mind that those participating are doing so in their spare time."
msgstr ""

#: ../../porting/introduction/Intro.rst:109
msgid "Prior knowledge and skills"
msgstr ""

#: ../../porting/introduction/Intro.rst:111
msgid "Porters come in all sizes and shapes, so to speak. Therefore, this guide does not presuppose extensive knowledge or skills in any particular field. You should, however, as a bare minimum be familiar with some common shell commands and be comfortable working from the terminal on you host PC. Furthermore, the guide is based on a host PC running Linux. If you have some knowledge of programming, this will come in handy at some point, especially if you are familiar with C / C++. Also, you should familiarize yourself with git and set up a Github or Gitlab account to keep track of your code changes. It is wise to start documenting your steps from the very beginning."
msgstr ""

#: ../../porting/introduction/Intro.rst:113
msgid "We have attempted to give a certain amount of explanation along the way. However, this guide is not an in-depth reference into the architecture and inner workings of Ubuntu Touch, and gaining a deeper understanding will consequently require an amount of research on your part."
msgstr ""

#: ../../porting/introduction/Intro.rst:118
msgid "Getting community help"
msgstr ""

#: ../../porting/introduction/Intro.rst:120
msgid "When you run into trouble, and you will, refer to one or more of the sources below:"
msgstr ""

#: ../../porting/introduction/Intro.rst:122
msgid "`Telegram: @ubports_porting <https://t.me/ubports_porting>`_"
msgstr ""

#: ../../porting/introduction/Intro.rst:123
msgid "`The UBports Forum <https://forums.ubports.com/category/33/porting>`_"
msgstr ""

#: ../../porting/introduction/Intro.rst:128
msgid "General advice"
msgstr ""

#: ../../porting/introduction/Intro.rst:130
msgid "The more rigorous you are at making notes and documenting your steps, the less time you will spend backtracking your steps and guessing your way along. When dealing with issues that arise along the way, it is wise to work on them one at a time. If you try to correct several things at once, you risk ending up trying to guess which changes solved a given issue, which easily leads to breaking the functionality in question once more at some later stage."
msgstr ""

#: ../../porting/introduction/Intro.rst:132
msgid "If you are not discouraged after reading this, we welcome your efforts and wish you the best of luck!"
msgstr ""

#: ../../porting/introduction/Intro.rst:134
msgid "The next section presents a key to the rest of this guide."
msgstr ""

#: ../../porting/introduction/Preparations.rst:4
msgid "Preparations"
msgstr ""

#: ../../porting/introduction/Preparations.rst:6
msgid "Not all devices can be made to run Ubuntu Touch. Research your target device before you start."
msgstr ""

#: ../../porting/introduction/Preparations.rst:8
msgid "To determine your device's specifications, search for it on `GSM Arena <https://www.gsmarena.com>`_ and/or `Device Specification <https://www.devicespecifications.com/en>`_. Refer to `Pick an Android target device in the Halium Porting Guide <http://docs.halium.org/en/latest/porting/first-steps.html#pick-an-android-target-device>`_ for further information on requirements and how to check if your device qualifies."
msgstr ""

#: ../../porting/introduction/Preparations.rst:14
msgid "Locate relevant guides and other information"
msgstr ""

#: ../../porting/introduction/Preparations.rst:16
msgid "If your desired target device complies to the above, the next thing to do is locate the available guides and other documentation. This step will help you later on when you run into issues developing your port. For now, the main thing to look for is how to unlock your bootloader. (See below)."
msgstr ""

#: ../../porting/introduction/Preparations.rst:18
msgid "Head over to the `LineageOS Wiki <https://wiki.lineageos.org/>`_. Look up your device and read and bookmark the guides that are listed there. Try a web search for additional information, specifying both its retail name and the code name you found on the LineageOS site. Be careful to check that the information you gather applies to your specific device, keeping in mind that many devices are sold in a number of different variants with different hardware specifications."
msgstr ""

#: ../../porting/introduction/Preparations.rst:20
msgid "Another rich source of information is the `XDA Developers Forum <https://www.xda-developers.com/>`_."
msgstr ""

#: ../../porting/introduction/Preparations.rst:25
msgid "Unlock the bootloader"
msgstr ""

#: ../../porting/introduction/Preparations.rst:27
msgid "Vendors usually provide their devices in a locked bootloader state. This is a kind of software \"seal\" intended to prevent modifications directly to the operating system and system software. If you unlock the bootloader, you will be able to make such modifications, but in this state your device's warranty might be void. The choice is yours, but this step is mandatory if you wish to install Ubuntu Touch on the device."
msgstr ""

#: ../../porting/introduction/Preparations.rst:29
msgid "Devices differ and there is no general method that covers all makes and models. Therefore, you need to check the aforementioned guides for instructions on how to unlock the bootloader of your particular device."
msgstr ""

#: ../../porting/introduction/Preparations.rst:34
msgid "Install TWRP recovery"
msgstr ""

#: ../../porting/introduction/Preparations.rst:36
msgid "You need to install a custom recovery image on your device in order to handle formatting and flashing image files onto it. Head over to the `Team Win Recovery Project <https://twrp.me/Devices/>`_  and locate the image file for your device. Follow the installation instructions provided on the website."
msgstr ""

#: ../../porting/introduction/Preparations.rst:41
msgid "Recommendations for the host/build PC"
msgstr ""

#: ../../porting/introduction/Preparations.rst:43
msgid "The remainder of this guide presumes you are using a build PC running Linux. Although high performance always is nice, stability and sufficient RAM and harddisk space are the main concerns here. You do not need the latest and the best hardware, nor do you need the latest distribution release. In fact, it is not uncommon to run into issues when choosing the very newest release, as some of the software needed may not yet have been built for it. For example, as of writing the latest release of Ubuntu Linux is 20.04, but many still recommend using the previous long term support release, 18.04."
msgstr ""

#: ../../porting/introduction/Preparations.rst:45
msgid "Having completed the steps above, you are now ready to set up your build environment and start the porting process per se (next section)."
msgstr ""

#: ../../porting/introduction/Setting_up.rst:4
msgid "Setting up the build environment"
msgstr ""

#: ../../porting/introduction/Setting_up.rst:6
msgid "Your host PC needs a number of tools installed before you can begin to port. This section describes the necessary preparations."
msgstr ""

#: ../../porting/introduction/Setting_up.rst:9
msgid "Prerequisites"
msgstr ""

#: ../../porting/introduction/Setting_up.rst:11
msgid "When setting up the build environment you need to have Python 3.6 or newer installed on your system. This can be installed via your system's package management system. Significant changes in syntax were introduced from Python 2 to Python 3, and some stages of the porting process may require Python 2 instead of Python 3. To check which version is active on your system, type::"
msgstr ""

#: ../../porting/introduction/Setting_up.rst:16
msgid "Any Linux distribution can easily be set up to switch between Python versions. Consult the documentation for your distribution to find out how this can be done."
msgstr ""

#: ../../porting/introduction/Setting_up.rst:19
msgid "Debian (Stretch or newer) / Ubuntu (16.04 or 18.04)"
msgstr ""

#: ../../porting/introduction/Setting_up.rst:21
#: ../../porting/introduction/Setting_up.rst:41
msgid "If your host PC has a 64-bit architecture (amd64), enable the usage of the i386 architecture::"
msgstr ""

#: ../../porting/introduction/Setting_up.rst:25
#: ../../porting/introduction/Setting_up.rst:45
msgid "Update your package lists to take advantage of the new architecture::"
msgstr ""

#: ../../porting/introduction/Setting_up.rst:29
#: ../../porting/introduction/Setting_up.rst:49
msgid "Install the required dependencies::"
msgstr ""

#: ../../porting/introduction/Setting_up.rst:39
msgid "Ubuntu (20.04 or newer)"
msgstr ""

#: ../../porting/introduction/Setting_up.rst:59
msgid "Create a directory named 'bin' in your home directory, and include it in your path::"
msgstr ""

#: ../../porting/introduction/Setting_up.rst:65
msgid "Download the repo script and make it executable::"
msgstr ""

#: ../../porting/introduction/Setting_up.rst:71
msgid "Arch"
msgstr ""

#: ../../porting/introduction/Setting_up.rst:73
msgid "If your host PC has a 64-bit architecture, you need to add the [multilib] repository to your /etc/pacman.conf . This will allow you to install and run i686 packages. Please refer to `‘Official Repositories/multilib’ on the Arch Wiki <https://wiki.archlinux.org/index.php/Official_repositories>`_."
msgstr ""

#: ../../porting/introduction/Setting_up.rst:75
msgid "Make sure you have the base-devel package installed."
msgstr ""

#: ../../porting/introduction/Setting_up.rst:77
msgid "Install the required dependencies from AUR::"
msgstr ""

#: ../../porting/introduction/index.rst:2
msgid "Introduction"
msgstr ""

#: ../../porting/introduction/index.rst:4
msgid "Porting is the process of making Ubuntu Touch run on new hardware, i.e. on devices that have not previously been able to run Ubuntu Touch."
msgstr ""

#: ../../porting/introduction/index.rst:6
msgid "On the vast majority of commercially available devices crucial parts of their systems are not open source. Furthermore, these proprietary parts are specific, not only to the manufacturer, but usually also to the individual model."
msgstr ""

#: ../../porting/introduction/index.rst:8
msgid "Porting Ubuntu Touch involves building it in such a way as to integrate it with these proprietary components on a device so as to enable it to \"talk to\" the device hardware."
msgstr ""

#: ../../porting/introduction/index.rst:10
msgid "Before attempting to port Ubuntu Touch to a new device, there are a few things to understand and consider, some research to be done, and a suitable build environment needs to be set up. This section addresses these points."
msgstr ""
